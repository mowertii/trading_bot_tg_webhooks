PROJECT EXPORT

PROJECT STRUCTURE:

📁 app
  📁 bot
    📁 handlers
      📄 __init__.py
      📄 balance_handler.py
      📄 figi_handler.py
      📄 init.py
      📄 position_handler.py
      📄 trade_handlers.py
    📄 __init__.py
    📄 main.py
  📁 scripts
    📁 __pycache__
      📄 tinkoff_check.cpython-311.pyc
    📄 tinkoff_check.py
  📁 trading
    📁 __pycache__
      📄 __init__.cpython-311.pyc
      📄 tinkoff_client.cpython-311.pyc
    📄 __init__.py
    📄 init.py
    📄 models.py
    📄 order_executor.py
    📄 order_watcher.py
    📄 risk_manager.py
    📄 test_tinkoff.py
    📄 tinkoff_client.py
  📄 __init__.py
  📄 config.py
  📄 Dockerfile
  📄 Dockerfile.last
  📄 notifications.py
  📄 redis_queue.py
  📄 requirements.txt
📁 db
  📄 init.sql
📄 .env
📄 .gitignore
📄 docker-compose.yml
📄 project-export.txt

FILES:

=== .env ===

BOT_TOKEN=7627503533:AAHJuYt3Bh7k-Y0SyOEeujPJ_4wjMj8c555
TARGET_USER_ID=1822765755
TINKOFF_TOKEN=t.cEGrGB9IbFCVpLzEO94lOx0_n0av3Nwq0pAWhVmpMIR27-bI8pPjomMZiOSuRzScDUyt7XwTMKkFvhfuMpQ555
ACCOUNT_ID=2213960479
REDIS_URL=redis://redis:6379/0
POSTGRES_DB=trading_data  # Должно совпадать с именем из docker-compose
POSTGRES_USER=bot
POSTGRES_PASSWORD=11111111
DB_URL=postgresql://bot:11111111@db:5432/trading_data


========================================

=== app\config.py ===

# config.py
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    BOT_TOKEN = os.getenv("BOT_TOKEN")
    TINKOFF_TOKEN = os.getenv("TINKOFF_TOKEN")
    ACCOUNT_ID = os.getenv("ACCOUNT_ID")
    LOG_LEVEL = os.getenv("LOG_LEVEL", "DEBUG")    


========================================

=== app\scripts\tinkoff_check.py ===

import os
import asyncio
from tinkoff.invest import AsyncClient, InstrumentIdType
from trading.tinkoff_client import TinkoffClient

async def main():
    token = os.getenv("TINKOFF_TOKEN")
    account_id = os.getenv("ACCOUNT_ID")
    
    client = TinkoffClient(token, account_id)
    
    # Тест поиска FIGI
    figi = await client.get_figi_by_ticker("SBER")
    print(f"FIGI для SBER: {figi}")
    
    # Проверка инструмента
    async with AsyncClient(token) as api_client:
        instrument = await api_client.instruments.get_instrument_by(
            id_type=InstrumentIdType.INSTRUMENT_ID_TYPE_FIGI,
            id=figi
        )
        print(f"Информация об инструменте: {instrument}")

if __name__ == "__main__":
    asyncio.run(main())

========================================

=== app\scripts\__pycache__\tinkoff_check.cpython-311.pyc ===

�
    �0h"  �                   �x   � d dl Z d dlZd dlmZmZ d dlmZ d� Zedk    r ej	         e�   �         �  �         dS dS )�    N)�AsyncClient�InstrumentIdType)�TinkoffClientc               �   ��  K  � t          j        d�  �        } t          j        d�  �        }t          | |�  �        }|�                    d�  �        � d {V ��}t	          d|� ��  �         t          | �  �        4 �d {V ��}|j        �                    t          j	        |��  �        � d {V ��}t	          d|� ��  �         d d d �  �        �d {V �� d S # 1 �d {V ��swxY w Y   d S )N�TINKOFF_TOKEN�
ACCOUNT_ID�SBERu   FIGI для SBER: )�id_type�idu2   Информация об инструменте: )
�os�getenvr   �get_figi_by_ticker�printr   �instruments�get_instrument_byr   �INSTRUMENT_ID_TYPE_FIGI)�token�
account_id�client�figi�
api_client�
instruments         �/app/scripts/tinkoff_check.py�mainr      s�  � � � ��I�o�&�&�E���<�(�(�J��5�*�-�-�F� �*�*�6�2�2�2�2�2�2�2�2�D�	�
%�t�
%�
%�&�&�&� �5�!�!� Q� Q� Q� Q� Q� Q� Q�Z�%�1�C�C�$�<�� D� 
� 
� 
� 
� 
� 
� 
� 
�
� 	�O�:�O�O�P�P�P�Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q���� Q� Q� Q� Q� Q� Qs   �=?C�
C�C�__main__)
r   �asyncio�tinkoff.investr   r   �trading.tinkoff_clientr   r   �__name__�run� �    r   �<module>r#      s�   �� 	�	�	�	� ���� 8� 8� 8� 8� 8� 8� 8� 8� 0� 0� 0� 0� 0� 0�Q� Q� Q�$ �z����G�K���������� �r"   

========================================

=== app\bot\handlers\figi_handler.py ===

from telegram import Update, Message
from telegram.ext import ContextTypes
from telegram.helpers import escape_markdown
from tinkoff.invest import AsyncClient, InstrumentShort
import os
import logging

logger = logging.getLogger(__name__)

async def handle_figi_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        message = update.message or update.channel_post
        if not message or not message.text:
            return

        # Извлекаем название инструмента после команды figi
        parts = message.text.split(maxsplit=1)
        if len(parts) < 2:
            await message.reply_text("❌ Укажите название инструмента")
            return

        instrument_name = parts[1].strip()
        await process_figi_request(message, instrument_name)

    except Exception as e:
        logger.error(f"Error: {str(e)}", exc_info=True)
        await message.reply_text("⚠️ Ошибка обработки запроса")

async def process_figi_request(message: Message, instrument_name: str):
    try:
        token = os.getenv("TINKOFF_TOKEN")
        if not token:
            logger.error("TINKOFF_TOKEN not configured!")
            await message.reply_text("❌ Ошибка конфигурации")
            return

        async with AsyncClient(token) as client:
            # Ищем инструмент
            response = await client.instruments.find_instrument(query=instrument_name)
            
            if not response.instruments:
                await message.reply_text(f"❌ Инструмент '{escape_markdown(instrument_name, version=2)}' не найден")
                return

            # Берем первый результат и экранируем все поля
            instrument = response.instruments[0]
            safe_data = {
                'name': escape_markdown(instrument.name, version=2),
                'figi': escape_markdown(instrument.figi, version=2),
                'ticker': escape_markdown(instrument.ticker, version=2)
            }

            response_text = (
                f"🔍 *{safe_data['name']}*\n"
                f"FIGI: \`{safe_data['figi']}\`\n"
                f"Тикер: {safe_data['ticker']}"
            )
            
            await message.reply_text(response_text, parse_mode='MarkdownV2')

    except Exception as e:
        logger.error(f"API Error: {str(e)}", exc_info=True)
        await message.reply_text("⚠️ Ошибка подключения к брокеру")


========================================

=== app\bot\handlers\__init__.py ===

from .trade_handlers import handle_buy, handle_sell
from .balance_handler import handle_balance
from .figi_handler import handle_figi_message
from .position_handler import handle_positions



========================================

=== app\bot\handlers\balance_handler.py ===

from telegram import Update
from telegram.ext import ContextTypes
from trading.tinkoff_client import TinkoffClient
import os
import logging
import asyncio  

logger = logging.getLogger(__name__)

async def handle_balance(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        message = update.message or update.channel_post
        client = TinkoffClient(os.getenv("TINKOFF_TOKEN"), os.getenv("ACCOUNT_ID"))
        
        balance = await client.get_balance_async()
        logger.debug(f"Raw balance data: {balance}")
        
        await message.reply_text(f"💰 Баланс: {balance:.2f} RUB")
    except Exception as e:
        logger.error(f"Balance error: {str(e)}", exc_info=True)
        await message.reply_text("❌ Ошибка получения баланса")


========================================

=== app\bot\handlers\trade_handlers.py ===

# app/bot/handlers/trade_handlers.py
from telegram import Update
from telegram.ext import ContextTypes
import os
import logging
import asyncio
from decimal import Decimal
from trading.tinkoff_client import TinkoffClient, Position 
from trading.order_executor import OrderExecutor

logger = logging.getLogger(__name__)

class TradeError(Exception):
    pass

async def _process_trade_command(update: Update, context: ContextTypes.DEFAULT_TYPE, action: str):
    try:
        message = update.message or update.channel_post
        if not message or not message.text:
            return

        instrument = message.text.split()[1].upper()
        logger.info(f"Processing {action.upper()} command for {instrument}")

        tinkoff_token = os.getenv("TINKOFF_TOKEN")
        account_id = os.getenv("ACCOUNT_ID")
        
        client = TinkoffClient(tinkoff_token, account_id)
        executor = OrderExecutor(tinkoff_token, account_id)

        figi = await client.get_figi(instrument)
        if not figi:
            raise TradeError(f"Инструмент {instrument} не найден")

        positions = await client.get_positions_async()
        
        # Обработка buy/sell через единый метод execute_smart_order
        if action == 'buy':
            await _handle_trade_logic(
                client=client,
                executor=executor,
                figi=figi,
                instrument=instrument,
                positions=positions,
                direction='long',
                risk_percent=Decimal('0.4')  # 40% от баланса для лонга
            )
        elif action == 'sell':
            await _handle_trade_logic(
                client=client,
                executor=executor,
                figi=figi,
                instrument=instrument,
                positions=positions,
                direction='short',
                risk_percent=Decimal('0.3')  # 30% от баланса для шорта
            )

        await message.reply_text(f"✅ Операция {action.upper()} для {instrument} выполнена")

    except TradeError as e:
        await message.reply_text(f"⚠️ {str(e)}")
    except Exception as e:
        logger.error(f"Ошибка: {str(e)}", exc_info=True)
        await message.reply_text("❌ Ошибка выполнения операции")

async def _handle_trade_logic(
    client: TinkoffClient,
    executor: OrderExecutor,
    figi: str,
    instrument: str,
    positions: list[Position],
    direction: str,
    risk_percent: Decimal
):
    """Обновленная логика с учетом изменений в API"""
    try:
        # Проверяем противоположную позицию
        opposite_pos = next(
            (p for p in positions 
             if p.ticker == instrument 
             and p.direction != direction),
            None
        )
        
        # Закрываем противоположную позицию если есть
        if opposite_pos:
            logger.info(f"Closing {opposite_pos.direction} position: {opposite_pos.lots} lots")
            await executor.execute_smart_order(
                figi=figi,
                desired_direction=opposite_pos.direction,
                amount=Decimal(opposite_pos.lots),
                close_only=True
            )
            await asyncio.sleep(1)

        # Получаем обновленный баланс
        balance = await client.get_balance_async()
        if balance <= 0:
            raise TradeError("Недостаточно средств")

        # Выполняем основную операцию
        await executor.execute_smart_order(
            figi=figi,
            desired_direction=direction,
            amount=balance * risk_percent
        )

    except Exception as e:
        logger.error(f"Trade error ({direction}): {str(e)}", exc_info=True)
        raise TradeError(f"Ошибка {direction} операции: {str(e)}")

async def handle_buy(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await _process_trade_command(update, context, 'buy')

async def handle_sell(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await _process_trade_command(update, context, 'sell')

========================================

=== app\bot\handlers\init.py ===

from .balance_handler import handle_balance
from .figi_handler import handle_figi_message
from .trade_handlers import handle_buy, handle_sell
from .position_handler import handle_positions


========================================

=== app\bot\handlers\position_handler.py ===

from telegram import Update
from telegram.ext import ContextTypes
from trading.tinkoff_client import TinkoffClient
import os
import logging

logger = logging.getLogger(__name__)

async def handle_positions(update: Update, context: ContextTypes.DEFAULT_TYPE):
    message = update.message or update.channel_post  # Исправление ошибки NoneType
    if not message:
        return

    try:
        client = TinkoffClient(os.getenv("TINKOFF_TOKEN"), os.getenv("ACCOUNT_ID"))
        positions = await client.get_positions_async()

        if not positions:
            await message.reply_text("🔍 Нет открытых позиций")
            return

        response = "📊 Открытые позиции:\n\n"
        for pos in positions:
            response += f"• {pos.ticker}: {pos.lots} лотов ({pos.direction.upper()})\n"

        await message.reply_text(response)

    except Exception as e:
        logger.error(f"Ошибка: {str(e)}", exc_info=True)
        await message.reply_text("❌ Ошибка при получении позиций")


========================================

=== app\bot\__init__.py ===

# Упрощаем импорт
from .handlers import (
    handle_balance,
    handle_figi_message,
    handle_buy,
    handle_sell,
    handle_positions
)


========================================

=== app\bot\main.py ===

from telegram import Update
from telegram.ext import (
    ApplicationBuilder,
    ContextTypes,
    MessageHandler,
    CommandHandler,
    filters
)
from bot.handlers import (
    handle_balance,
    handle_figi_message,
    handle_buy,
    handle_sell,
    handle_positions
)
import os
import logging
import re
import asyncio

# Импортируем новый функционал
from trading.order_executor import OrderExecutor
from trading.order_watcher import OrderWatcher  # <-- новый модуль

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.error(f"Ошибка: {context.error}", exc_info=True)
    try:
        message = update.message or update.channel_post
        if message:
            await message.reply_text("⚠️ Произошла внутренняя ошибка")
    except Exception as e:
        logger.error(f"Ошибка в error_handler: {str(e)}")

def setup_handlers(application):
    # Balance handler
    application.add_handler(MessageHandler(
        filters.TEXT & filters.Regex(re.compile(r'^(баланс|balance)$', re.IGNORECASE)),
        handle_balance
    ))
    
    # FIGI info handler
    application.add_handler(MessageHandler(
        filters.TEXT & filters.Regex(re.compile(r'^figi\s+\w+', re.IGNORECASE)),
        handle_figi_message
    ))
    
    # Positions handler
    application.add_handler(MessageHandler(
        filters.TEXT & filters.Regex(re.compile(r'^(состояние|positions)$', re.IGNORECASE)),
        handle_positions
    ))
    
    # Buy/Sell handlers
    application.add_handler(MessageHandler(
        filters.TEXT & filters.Regex(re.compile(r'^buy\s+\w+', re.IGNORECASE)),
        handle_buy
    ))
    
    application.add_handler(MessageHandler(
        filters.TEXT & filters.Regex(re.compile(r'^sell\s+\w+', re.IGNORECASE)),
        handle_sell
    ))

def main():
    token = os.getenv("BOT_TOKEN")
    tinkoff_token = os.getenv("TINKOFF_TOKEN")
    account_id = os.getenv("ACCOUNT_ID")
    chat_id = os.getenv("TG_CHAT_ID")  # Новый параметр (можно задать в .env)

    if not token:
        raise ValueError("Не задан BOT_TOKEN")
    if not tinkoff_token or not account_id:
        raise ValueError("Не заданы TINKOFF_TOKEN или ACCOUNT_ID")

    # Создаём Telegram-бот
    application = ApplicationBuilder().token(token).build()
    setup_handlers(application)
    application.add_error_handler(error_handler)

    # Создаём исполнителя и вотчера
    executor = OrderExecutor(tinkoff_token, account_id)
    watcher = OrderWatcher(
        tinkoff_token,
        account_id,
        executor,
        tg_bot=application.bot,
        chat_id=chat_id
    )

    # Запускаем вотчер в отдельной задаче
    loop = asyncio.get_event_loop()
    loop.create_task(watcher.watch_trades())

    logger.info("Бот запущен")
    application.run_polling()

if __name__ == '__main__':
    main()


========================================

=== app\Dockerfile.last ===

FROM python:3.10-slim

WORKDIR /app

# Кэширование зависимостей
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt \\
    && pip install aiohttp

# Отдельно копируем только нужные файлы
COPY config.py .
COPY trading/ ./trading/

# Добавляем проверку работоспособности
RUN python -c "from trading.order_executor import OrderExecutor; print('Module imports OK')" \\
    || (echo "Import error!" && exit 1)

CMD ["python", "-m", "trading.order_executor", "app.bot.main"]


========================================

=== app\Dockerfile ===

FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
RUN pip install --upgrade tinkoff-investments
RUN pip install uuid
RUN pip install --upgrade protobuf

# Копируем всю структуру проекта
COPY . .

# Устанавливаем переменную окружения для Python
ENV PYTHONPATH="\${PYTHONPATH}:/app"
ENV PYTHONPATH "\${PYTHONPATH}:/app:/app/trading:/app/bot"

CMD ["python", "-m", "bot.main"]


========================================

=== app\redis_queue.py ===

import redis
from pydantic import BaseModel
import json
from config import Settings

settings = Settings()

class RedisQueue:
    def __init__(self):
        self.redis = redis.Redis.from_url(settings.REDIS_URL)
        self.channel = 'trading_signals'

    async def publish_signal(self, signal: dict):
        self.redis.publish(self.channel, json.dumps(signal))

    async def listen_signals(self, callback):
        pubsub = self.redis.pubsub()
        pubsub.subscribe(self.channel)
        for message in pubsub.listen():
            if message['type'] == 'message':
                callback(json.loads(message['data']))

class TradeSignal(BaseModel):
    action: str  # buy/sell/balance
    figi: str = "NG_FIGI"  # Замените на реальный FIGI
    quantity: int = 1
    user_id: int
    chat_id: int


========================================

=== app\__init__.py ===



========================================

=== app\requirements.txt ===

python-telegram-bot>=20.0
# tinkoff-investments  # Актуальная версия API
# tinkoff-investments>=0.2.0b1 
tinkoff-investments
pydantic-settings>=2.0
redis>=4.5.4
asyncpg>=0.28.0
apscheduler>=3.10.0
aiohttp>=3.8.0
async-timeout>=4.0.2
backoff==2.2.1
pydantic>=2.0
numpy>=1.22.0  # Для RiskManager


========================================

=== app\trading\order_watcher.py ===

import logging
from tinkoff.invest import AsyncClient
from tinkoff.invest.async_services import AsyncServices
from .order_executor import OrderExecutor

logger = logging.getLogger(__name__)


class OrderWatcher:
    def __init__(self, token: str, account_id: str, executor: OrderExecutor, tg_bot=None, chat_id=None):
        self.token = token
        self.account_id = account_id
        self.executor = executor
        self.tg_bot = tg_bot
        self.chat_id = chat_id

    async def watch_trades(self):
        async with AsyncClient(self.token) as client:
            stream: AsyncServices.TradesStream = client.trades_stream
            logger.info("OrderWatcher запущен: слушаем поток сделок...")

            async for event in stream.trades_stream(accounts=[self.account_id]):
                try:
                    if not event.order_trades:
                        continue

                    figi = event.order_trades.figi
                    order_id = event.order_trades.order_id

                    # ✅ Определяем причину по словарю executor'а
                    reason = self.executor.order_reasons.get(order_id, "Неизвестно")

                    # Проверяем позицию после сделки
                    pos_type, qty = await self.executor._get_current_position(client, figi)
                    if not pos_type or qty == 0:
                        await self.executor._cancel_all_stop_orders(client, figi)
                        await self.executor._cancel_all_limit_orders(client, figi)

                        msg = f"ℹ️ Позиция по {figi} закрыта ({reason}). Все стопы и лимиты сняты."
                        logger.info(msg)

                        if self.tg_bot and self.chat_id:
                            try:
                                await self.tg_bot.send_message(chat_id=self.chat_id, text=msg)
                            except Exception as e:
                                logger.error(f"Ошибка при отправке уведомления: {e}")

                except Exception as e:
                    logger.error(f"Ошибка обработки события в OrderWatcher: {e}", exc_info=True)


========================================

=== app\trading\order_executor.py ===

from tinkoff.invest import (
    AsyncClient,
    OrderDirection,
    OrderType,
    InstrumentIdType,
    MoneyValue,
    StopOrderType,
    StopOrderExpirationType
)
from decimal import Decimal
import logging
import asyncio
from typing import Optional, Tuple
from dataclasses import dataclass

logger = logging.getLogger(__name__)

@dataclass
class TradeError(Exception):
    message: str


class OrderExecutor:
    def __init__(
        self,
        token: str,
        account_id: str,
        risk_percentage: Decimal = Decimal('0.4'),
        stop_loss_percent: Decimal = Decimal('0.51'),
        take_profit_percent: Decimal = Decimal('1.9'),
    ):
        self.token = token
        self.account_id = account_id
        self.risk_percentage = risk_percentage
        self.stop_loss_percent = stop_loss_percent / 100
        self.take_profit_percent = take_profit_percent / 100

        # ✅ Здесь храним соответствие order_id → причина
        self.order_reasons: dict[str, str] = {}

    # ---------------------------
    # Вспомогательные методы
    # ---------------------------
    def _money_value_to_decimal(self, money: MoneyValue) -> Decimal:
        if money is None:
            return Decimal(0)
        return Decimal(money.units) + Decimal(money.nano) / Decimal(1e9)

    async def _get_current_price(self, client: AsyncClient, figi: str) -> Decimal:
        last_prices = await client.market_data.get_last_prices(figi=[figi])
        price = last_prices.last_prices[0].price
        return Decimal(price.units) + Decimal(price.nano) / Decimal(1e9)

    async def _get_current_position(self, client: AsyncClient, figi: str) -> Tuple[Optional[str], int]:
        positions = await client.operations.get_positions(account_id=self.account_id)
        for future in positions.futures:
            if future.figi == figi:
                quantity = getattr(future, 'balance', 0)
                if quantity > 0:
                    return 'long', abs(quantity)
                elif quantity < 0:
                    return 'short', abs(quantity)
        return None, 0

    async def _get_available_funds(self, client: AsyncClient) -> Decimal:
        portfolio = await client.operations.get_portfolio(account_id=self.account_id)
        return self._money_value_to_decimal(portfolio.total_amount_currencies)

    # ---------------------------
    # Отмена ордеров
    # ---------------------------
    async def _cancel_all_limit_orders(self, client: AsyncClient, figi: str):
        orders = await client.orders.get_orders(account_id=self.account_id)
        for order in orders.orders:
            if order.figi == figi and order.order_type == OrderType.ORDER_TYPE_LIMIT:
                await client.orders.cancel_order(account_id=self.account_id, order_id=order.order_id)

    async def _cancel_all_stop_orders(self, client: AsyncClient, figi: str):
        stops = await client.stop_orders.get_stop_orders(account_id=self.account_id)
        for so in stops.stop_orders:
            if so.figi == figi:
                await client.stop_orders.cancel_stop_order(account_id=self.account_id, stop_order_id=so.stop_order_id)

    # ---------------------------
    # Закрытие позиции
    # ---------------------------
    async def _close_position(self, client: AsyncClient, figi: str, position_type: str, quantity: int):
        await self._cancel_all_stop_orders(client, figi)
        await self._cancel_all_limit_orders(client, figi)

        direction = (
            OrderDirection.ORDER_DIRECTION_SELL if position_type == 'long'
            else OrderDirection.ORDER_DIRECTION_BUY
        )
        order = await self._execute_order(
            client=client,
            figi=figi,
            quantity=quantity,
            direction=direction,
            order_type=OrderType.ORDER_TYPE_MARKET
        )
        # ✅ Запоминаем причину
        self.order_reasons[order.order_id] = "MARKET"
        return order

    # ---------------------------
    # Выставление защитных ордеров
    # ---------------------------
    async def _place_protection_orders(self, client: AsyncClient, figi: str, direction: str, entry_price: Decimal, quantity: int):
        instrument = (await client.instruments.get_instrument_by(
            id_type=InstrumentIdType.INSTRUMENT_ID_TYPE_FIGI,
            id=figi
        )).instrument
        min_price_increment = self._money_value_to_decimal(instrument.min_price_increment)

        if direction == 'long':
            stop_price = entry_price * (Decimal(1) - self.stop_loss_percent)
            take_profit_price = entry_price * (Decimal(1) + self.take_profit_percent)
            stop_direction = OrderDirection.ORDER_DIRECTION_SELL
        else:
            stop_price = entry_price * (Decimal(1) + self.stop_loss_percent)
            take_profit_price = entry_price * (Decimal(1) - self.take_profit_percent)
            stop_direction = OrderDirection.ORDER_DIRECTION_BUY

        stop_price = (stop_price // min_price_increment) * min_price_increment
        take_profit_price = (take_profit_price // min_price_increment) * min_price_increment

        def decimal_to_money(value: Decimal) -> MoneyValue:
            units = int(value)
            nano = int((value - units) * Decimal('1e9'))
            return MoneyValue(units=units, nano=nano)

        stop_price_money = decimal_to_money(stop_price)
        tp_price_money = decimal_to_money(take_profit_price)

        # Стоп-лосс
        stop_order = await client.stop_orders.post_stop_order(
            figi=figi,
            quantity=quantity,
            direction=stop_direction,
            account_id=self.account_id,
            stop_price=stop_price_money,
            price=stop_price_money,
            stop_order_type=StopOrderType.STOP_ORDER_TYPE_STOP_LOSS,
            expiration_type=StopOrderExpirationType.STOP_ORDER_EXPIRATION_TYPE_GOOD_TILL_CANCEL
        )
        self.order_reasons[stop_order.stop_order_id] = "STOP_LOSS"

        # Тейк-профит лимитом
        tp_order = await client.orders.post_order(
            figi=figi,
            quantity=quantity,
            direction=stop_direction,
            account_id=self.account_id,
            order_type=OrderType.ORDER_TYPE_LIMIT,
            price=tp_price_money
        )
        self.order_reasons[tp_order.order_id] = "TAKE_PROFIT"

    # ---------------------------
    # Исполнение ордеров
    # ---------------------------
    async def _execute_order(self, client: AsyncClient, figi: str, quantity: int, direction: OrderDirection, order_type: OrderType):
        return await client.orders.post_order(
            figi=figi,
            quantity=quantity,
            direction=direction,
            account_id=self.account_id,
            order_type=order_type
        )

    async def execute_smart_order(self, figi: str, desired_direction: str, amount: Decimal, close_only: bool = False):
        async with AsyncClient(self.token) as client:
            current_pos_type, current_pos_qty = await self._get_current_position(client, figi)

            if close_only:
                if current_pos_type:
                    await self._close_position(client, figi, current_pos_type, current_pos_qty)
                    return
                raise TradeError("Нет позиции для закрытия")

            direction_enum = (
                OrderDirection.ORDER_DIRECTION_BUY if desired_direction == 'long'
                else OrderDirection.ORDER_DIRECTION_SELL
            )

            if current_pos_type and current_pos_type != desired_direction:
                await self._close_position(client, figi, current_pos_type, current_pos_qty)

            futures_margin = await client.instruments.get_futures_margin(figi=figi)
            margin_field = 'initial_margin_on_buy' if desired_direction == 'long' else 'initial_margin_on_sell'
            go_per_lot = self._money_value_to_decimal(getattr(futures_margin, margin_field))
            available_funds = await self._get_available_funds(client)
            quantity = int((available_funds * self.risk_percentage) // go_per_lot)
            if quantity < 1:
                raise TradeError("Недостаточно средств")

            order = await self._execute_order(client, figi, quantity, direction_enum, OrderType.ORDER_TYPE_MARKET)
            self.order_reasons[order.order_id] = "MARKET"

            entry_price = await self._get_current_price(client, figi)
            await self._place_protection_orders(client, figi, desired_direction, entry_price, quantity)


========================================

=== app\trading\__init__.py ===



========================================

=== app\trading\test_tinkoff.py ===

# test_tinkoff.py
from trading.tinkoff_client import TinkoffClient
import asyncio

async def main():
    client = TinkoffClient(os.getenv("TINKOFF_TOKEN"), os.getenv("ACCOUNT_ID"))
    
    # Тест поиска FIGI
    figi = await client.get_figi_by_ticker_async("AAPL")
    print(f"FIGI для AAPL: {figi}")
    
    # Тест ордера
    result = await client.place_market_order_async(figi, 1, "buy")
    print(f"Результат ордера: {result}")

asyncio.run(main())


========================================

=== app\trading\tinkoff_client.py ===

from dataclasses import dataclass
from tinkoff.invest import (
    AsyncClient,
    InstrumentResponse,        
    PortfolioResponse,
    InstrumentIdType,
    MoneyValue
)
from decimal import Decimal
from typing import List, Optional
import logging


logger = logging.getLogger(__name__)

@dataclass
class Position:
    figi: str
    ticker: str
    lots: int
    direction: str

class TinkoffClient:
    def __init__(self, token: str, account_id: str):
        self.token = token
        self.account_id = account_id
        self.RUB_FIGI = "BBG0013HGFT4"

    async def _get_ticker_by_figi(self, figi: str) -> Optional[str]:
        """Получает тикер инструмента по FIGI"""
        async with AsyncClient(self.token) as client:
            try:
                instrument: InstrumentResponse = await client.instruments.get_instrument_by(
                    id_type=InstrumentIdType.INSTRUMENT_ID_TYPE_FIGI,
                    id=figi
                )
                return instrument.instrument.ticker
            except Exception as e:
                logger.error(f"Ошибка получения тикера для FIGI {figi}: {str(e)}")
                return None

    async def get_margin_attributes(self):
        async with AsyncClient(self.token) as client:
            return await client.operations.get_margin_attributes(account_id=self.account_id)

    async def get_positions_async(self) -> List[Position]:
        async with AsyncClient(self.token) as client:
            response = await client.operations.get_positions(account_id=self.account_id)
            positions = []
            
            for fut in response.futures:
                # Проверка актуальных полей
                lots = abs(fut.balance) if hasattr(fut, 'balance') else abs(fut.quantity)
                direction = 'long' if (fut.balance > 0 if hasattr(fut, 'balance') else fut.quantity > 0) else 'short'
                
                ticker = await self._get_ticker_by_figi(fut.figi)
                if not ticker:
                    ticker = fut.figi  # Используем FIGI если тикер не найден
                    
                positions.append(Position(
                    ticker=ticker,
                    figi=fut.figi,
                    lots=lots,
                    direction=direction
                ))
            
            # Логирование для отладки
            logger.debug(f"Структура позиций: {response}")
            return positions

    async def get_balance_async(self) -> Decimal:
        async with AsyncClient(self.token) as client:
            try:
                # Получаем информацию по валютам
                positions = await client.operations.get_positions(account_id=self.account_id)
                logger.debug(f"Raw positions response: {positions}")
                
                rub_balance = Decimal(0)
                
                for money in positions.money:
                    if money.currency == 'rub':
                        rub_balance += self._money_value_to_decimal(money)
                
                # Обрабатываем ценные бумаги с балансом в RUB
                for security in positions.securities:
                    if security.blocked == 0 and security.balance > 0:
                        instrument = await self._get_instrument_by_figi(security.figi)
                        if instrument and instrument.currency == 'rub':
                            last_price = await self._get_last_price(client, security.figi)
                            rub_balance += last_price * security.balance
                
                logger.info(f"Calculated RUB balance: {rub_balance}")
                return rub_balance
                
            except Exception as e:
                logger.error(f"Balance calculation error: {str(e)}", exc_info=True)
                raise

    async def _get_instrument_by_figi(self, figi: str):
        async with AsyncClient(self.token) as client:
            return await client.instruments.get_instrument_by(
                id_type=InstrumentIdType.INSTRUMENT_ID_TYPE_FIGI,
                id=figi
            )

    async def _get_last_price(self, client: AsyncClient, figi: str) -> Decimal:
        last_price = await client.market_data.get_last_prices(figi=[figi])
        if last_price.last_prices:
            price = last_price.last_prices[0].price
            return Decimal(price.units) + Decimal(price.nano) / Decimal(1e9)
        return Decimal(0)

    def _calculate_available_funds(self, portfolio: PortfolioResponse) -> Decimal:
        cash = next(
            (pos for pos in portfolio.positions 
             if pos.figi == self.RUB_FIGI),
            None
        )
        return self._money_value_to_decimal(cash.current_price) if cash else Decimal(0)

    async def get_figi(self, instrument: str) -> Optional[str]:
        async with AsyncClient(self.token) as client:
            # Убрали некорректный параметр instrument_status
            response = await client.instruments.find_instrument(query=instrument)
            return response.instruments[0].figi if response.instruments else None


    @staticmethod
    def _money_value_to_decimal(money: MoneyValue) -> Decimal:
        """Конвертация MoneyValue в Decimal"""
        return Decimal(money.units) + Decimal(money.nano) / Decimal(1e9)


    async def get_balance_async(self) -> Decimal:
        """Получение доступного RUB баланса"""
        async with AsyncClient(self.token) as client:
            try:
                positions = await client.operations.get_positions(account_id=self.account_id)
                rub_balance = Decimal(0)
                
                # Обрабатываем только рублёвые позиции
                for money in positions.money:
                    if money.currency == 'rub':
                        rub_balance += self._money_value_to_decimal(money)
                
                logger.debug(f"Raw RUB balance: {rub_balance}")
                return rub_balance

            except Exception as e:
                logger.error(f"Balance error: {str(e)}", exc_info=True)
                raise

========================================

=== app\trading\init.py ===

from .tinkoff_client import TinkoffClient, Position
from .order_executor import OrderExecutor

__all__ = ['TinkoffClient', 'OrderExecutor', 'Position']


========================================

=== app\trading\models.py ===

from pydantic import BaseModel
from datetime import datetime

class TradeSignal(BaseModel):
    figi: str
    direction: str  # buy/sell
    quantity: int
    timestamp: datetime

class AccountBalance(BaseModel):
    total: float
    available: float
    currency: str
    updated_at: datetime

class InstrumentCache(BaseModel):
    ticker: str
    figi: str
    min_lot: int
    updated_at: datetime    


========================================

=== app\trading\risk_manager.py ===

from decimal import Decimal
from tinkoff.invest import AsyncClient, Quotation, InstrumentShort
from redis import Redis
import logging
from config import Settings

logger = logging.getLogger(__name__)

class RiskManager:
    def __init__(self, token: str, account_id: str):
        self.token = token
        self.account_id = account_id
        self.settings = Settings()
        self.redis = Redis.from_url(self.settings.REDIS_URL)
        self.cache_ttl = 86400  # 24 часа

    async def get_figi(self, instrument_name: str) -> str:
        """Поиск FIGI с кэшированием"""
        cache_key = f"figi:{instrument_name}"
        cached = self.redis.get(cache_key)
        
        if cached:
            return cached.decode()

        async with AsyncClient(self.token) as client:
            try:
                response = await client.instruments.find_instrument(query=instrument_name)
                for instrument in response.instruments:
                    if instrument.ticker.upper() == instrument_name.upper():
                        figi = instrument.figi
                        self.redis.setex(cache_key, self.cache_ttl, figi)
                        return figi
                raise ValueError(f"Инструмент {instrument_name} не найден")
            except Exception as e:
                logger.error(f"FIGI search error: {str(e)}")
                raise

    def _validate_min_lot(self, instrument: InstrumentShort, quantity: int):
        """Проверка минимального лота"""
        if not hasattr(instrument, 'min_quantity_increment') or instrument.min_quantity_increment is None:
            raise ValueError("Инструмент не имеет минимального лота")

        min_lot = instrument.min_quantity_increment
        if quantity < min_lot:
            raise ValueError(f"Количество {quantity} меньше минимального лота {min_lot}")

    async def validate_order(self, figi: str, quantity: int) -> dict:
        """Основная проверка перед исполнением ордера"""
        try:
            async with AsyncClient(self.token) as client:
                instrument = await client.instruments.get_instrument_by_figi(figi=figi)
                
                # Валидация минимального лота
                self._validate_min_lot(instrument, quantity)

                # Получение цены и расчет стоимости
                last_price = await self._get_last_price(client, figi)
                position_cost = last_price * quantity * instrument.lot

                # Получение доступного баланса
                portfolio = await client.operations.get_portfolio(account_id=self.account_id)
                total = portfolio.total_amount_portfolio
                available = self._quotation_to_decimal(total)

                # Проверки
                checks = {
                    'min_lot': quantity >= instrument.min_quantity_increment,
                    'balance': position_cost <= available * Decimal('0.5'),
                    'daily_limit': position_cost <= Decimal('100000'),
                    'instrument_active': instrument.api_trade_available_flag
                }

                return {
                    'status': 'approved' if all(checks.values()) else 'rejected',
                    'checks': checks
                }

        except Exception as e:
            logger.error(f"Risk validation error: {str(e)}")
            return {
                'status': 'error',
                'message': str(e),
                'checks': {}
            }

    async def _get_last_price(self, client: AsyncClient, figi: str) -> Decimal:
        """Получение последней цены"""
        order_book = await client.market_data.get_order_book(figi=figi, depth=1)
        return self._quotation_to_decimal(order_book.last_price)

    def _quotation_to_decimal(self, q: Quotation) -> Decimal:
        """Конвертация Quotation в Decimal"""
        return Decimal(q.units) + Decimal(q.nano) / 1e9


========================================

=== app\trading\__pycache__\__init__.cpython-311.pyc ===

�
    �4h    �                   �   � d S )N� r   �    �/app/trading/__init__.py�<module>r      s   �� � r   

========================================

=== app\trading\__pycache__\tinkoff_client.cpython-311.pyc ===

�
    �4h[  �                   �|   � d dl mZmZmZmZ d dlmZ d dlmZm	Z	 d dl
Z
 e
j        e�  �        Z G d� d�  �        ZdS )�    )�AsyncClient�PortfolioResponse�PositionsResponse�
MoneyValue)�Decimal)�List�OptionalNc                   �r   � e Zd Zdedefd�Zdefd�Zdedefd�Zdede	e         fd	�Z
edefd
��   �         ZdS )�TinkoffClient�token�
account_idc                 �0   � || _         || _        d| _        d S )N�BBG0013HGFT4)r   r   �RUB_FIGI)�selfr   r   s      �/app/trading/tinkoff_client.py�__init__zTinkoffClient.__init__   s   � ���
�$���&�����    �returnc              �   ��   K  � t          | j        �  �        4 �d {V ��}|j        �                    | j        ��  �        � d {V ��}| �                    |�  �        cd d d �  �        �d {V �� S # 1 �d {V ��swxY w Y   d S )N)r   )r   r   �
operations�get_portfolior   �_calculate_available_funds)r   �client�responses      r   �get_balance_asynczTinkoffClient.get_balance_async   s$  � � � ��t�z�*�*� 	=� 	=� 	=� 	=� 	=� 	=� 	=�f�#�.�<�<��?� =� � � � � � � � �H� �2�2�8�<�<�		=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=���� 	=� 	=� 	=� 	=� 	=� 	=s   �;A+�+
A5�8A5�	portfolioc                 �   � � t          � fd�|j        D �   �         d �  �        }|r� �                    |j        �  �        nt	          d�  �        S )Nc              3   �<   �K  � | ]}|j         �j        k    �|V � �d S )N)�figir   )�.0�posr   s     �r   �	<genexpr>z;TinkoffClient._calculate_available_funds.<locals>.<genexpr>   s=   �� � � � +� +�S���D�M�)�)� �)�)�)�)�+� +r   r   )�next�	positions�_money_value_to_decimal�current_pricer   )r   r   �cashs   `  r   r   z(TinkoffClient._calculate_available_funds   si   �� ��+� +� +� +�I�/� +� +� +��
� 
��
 DH�W�t�+�+�D�,>�?�?�?�W�UV�Z�Z�Wr   �
instrumentc              �   ��   K  � t          | j        �  �        4 �d {V ��}|j        �                    |��  �        � d {V ��}|j        r|j        d         j        nd cd d d �  �        �d {V �� S # 1 �d {V ��swxY w Y   d S )N)�queryr   )r   r   �instruments�find_instrumentr    )r   r)   r   r   s       r   �get_figizTinkoffClient.get_figi"   s<  � � � ��t�z�*�*� 	R� 	R� 	R� 	R� 	R� 	R� 	R�f�#�/�?�?�j�?�Q�Q�Q�Q�Q�Q�Q�Q�H�3;�3G�Q�8�'��*�/�/�T�	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R���� 	R� 	R� 	R� 	R� 	R� 	Rs   �<A,�,
A6�9A6c                 ��   � t          | d�  �        rIt          | d�  �        r9t          | j        �  �        t          | j        �  �        t          d�  �        z  z   S t          d�  �        S )N�units�nanoi ʚ;r   )�hasattrr   r0   r1   )�moneys    r   r&   z%TinkoffClient._money_value_to_decimal(   s]   � ��5�'�"�"� 	O�w�u�f�'=�'=� 	O��5�;�'�'�'�%�*�*=�*=�����*N�N�N��q�z�z�r   N)�__name__�
__module__�__qualname__�strr   r   r   r   r   r	   r.   �staticmethodr&   � r   r   r   r      s�   � � � � � �'�c� '�s� '� '� '� '�
=�� =� =� =� =�X�4E� X�'� X� X� X� X�R�� R��#�� R� R� R� R� ��'� � � � �\�� � r   r   )�tinkoff.investr   r   r   r   �decimalr   �typingr   r	   �logging�	getLoggerr4   �loggerr   r9   r   r   �<module>r@      s�   ��� � � � � � � � � � � � � � � � � � !� !� !� !� !� !� !� !� ����	��	�8�	$�	$��� � � � � � � � � r   

========================================

=== app\notifications.py ===

from telegram import Bot
import logging

logger = logging.getLogger(__name__)

class Notifier:
    def __init__(self, token: str, chat_id: int):
        self.bot = Bot(token=token)
        self.chat_id = chat_id

    def send_order_confirmation(self, order_details: dict):
        message = (
            f"🔄 Ордер исполнен:\\n"
            f"FIGI: {order_details.figi}\\n"
            f"Направление: {order_details.direction}\\n"
            f"Количество: {order_details.quantity}\\n"
            f"Цена: {order_details.executed_price}"
        )
        self.bot.send_message(chat_id=self.chat_id, text=message)


========================================

=== docker-compose.yml ===

version: '3.8'

services:
  bot:
    build: ./app
    command: python -m bot.main
    env_file: .env
    environment:
      - BOT_TOKEN=${BOT_TOKEN}
      - TARGET_USER_ID=${TARGET_USER_ID}
    restart: unless-stopped
    depends_on:
      - redis
      - db

  redis:
    image: redis:alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  db:
    image: postgres:13
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 5s
      timeout: 5s
      retries: 10
    volumes:
      - postgres_data:/var/lib/postgresql/data        

volumes:
  redis_data:
  postgres_data:


========================================

=== .gitignore ===

.env
*.sh
*.info
*.proj
.*
proj.*
backup.*
backup*
save*
*workly
temp
trader*
*.pyc
__pycache__


========================================

=== project-export.txt ===

PROJECT EXPORT

PROJECT STRUCTURE:

📁 app
  📁 bot
    📁 handlers
      📄 __init__.py
      📄 balance_handler.py
      📄 figi_handler.py
      📄 init.py
      📄 position_handler.py
      📄 trade_handlers.py
    📄 __init__.py
    📄 main.py
  📁 scripts
    📁 __pycache__
      📄 tinkoff_check.cpython-311.pyc
    📄 tinkoff_check.py
  📁 trading
    📁 __pycache__
      📄 __init__.cpython-311.pyc
      📄 tinkoff_client.cpython-311.pyc
    📄 __init__.py
    📄 init.py
    📄 models.py
    📄 order_executor.py
    📄 order_watcher.py
    📄 risk_manager.py
    📄 test_tinkoff.py
    📄 tinkoff_client.py
  📄 __init__.py
  📄 config.py
  📄 Dockerfile
  📄 Dockerfile.last
  📄 notifications.py
  📄 redis_queue.py
  📄 requirements.txt
📁 db
  📄 init.sql
📄 .env
📄 .gitignore
📄 docker-compose.yml

FILES:

=== .env ===

BOT_TOKEN=7627503533:AAHJuYt3Bh7k-Y0SyOEeujPJ_4wjMj8c555
TARGET_USER_ID=1822765755
TINKOFF_TOKEN=t.cEGrGB9IbFCVpLzEO94lOx0_n0av3Nwq0pAWhVmpMIR27-bI8pPjomMZiOSuRzScDUyt7XwTMKkFvhfuMpQ555
ACCOUNT_ID=2213960479
REDIS_URL=redis://redis:6379/0
POSTGRES_DB=trading_data  # Должно совпадать с именем из docker-compose
POSTGRES_USER=bot
POSTGRES_PASSWORD=11111111
DB_URL=postgresql://bot:11111111@db:5432/trading_data


========================================

=== app\config.py ===

# config.py
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    BOT_TOKEN = os.getenv("BOT_TOKEN")
    TINKOFF_TOKEN = os.getenv("TINKOFF_TOKEN")
    ACCOUNT_ID = os.getenv("ACCOUNT_ID")
    LOG_LEVEL = os.getenv("LOG_LEVEL", "DEBUG")    


========================================

=== app\scripts\tinkoff_check.py ===

import os
import asyncio
from tinkoff.invest import AsyncClient, InstrumentIdType
from trading.tinkoff_client import TinkoffClient

async def main():
    token = os.getenv("TINKOFF_TOKEN")
    account_id = os.getenv("ACCOUNT_ID")
    
    client = TinkoffClient(token, account_id)
    
    # Тест поиска FIGI
    figi = await client.get_figi_by_ticker("SBER")
    print(f"FIGI для SBER: {figi}")
    
    # Проверка инструмента
    async with AsyncClient(token) as api_client:
        instrument = await api_client.instruments.get_instrument_by(
            id_type=InstrumentIdType.INSTRUMENT_ID_TYPE_FIGI,
            id=figi
        )
        print(f"Информация об инструменте: {instrument}")

if __name__ == "__main__":
    asyncio.run(main())

========================================

=== app\scripts\__pycache__\tinkoff_check.cpython-311.pyc ===

�
    �0h"  �                   �x   � d dl Z d dlZd dlmZmZ d dlmZ d� Zedk    r ej	         e�   �         �  �         dS dS )�    N)�AsyncClient�InstrumentIdType)�TinkoffClientc               �   ��  K  � t          j        d�  �        } t          j        d�  �        }t          | |�  �        }|�                    d�  �        � d {V ��}t	          d|� ��  �         t          | �  �        4 �d {V ��}|j        �                    t          j	        |��  �        � d {V ��}t	          d|� ��  �         d d d �  �        �d {V �� d S # 1 �d {V ��swxY w Y   d S )N�TINKOFF_TOKEN�
ACCOUNT_ID�SBERu   FIGI для SBER: )�id_type�idu2   Информация об инструменте: )
�os�getenvr   �get_figi_by_ticker�printr   �instruments�get_instrument_byr   �INSTRUMENT_ID_TYPE_FIGI)�token�
account_id�client�figi�
api_client�
instruments         �/app/scripts/tinkoff_check.py�mainr      s�  � � � ��I�o�&�&�E���<�(�(�J��5�*�-�-�F� �*�*�6�2�2�2�2�2�2�2�2�D�	�
%�t�
%�
%�&�&�&� �5�!�!� Q� Q� Q� Q� Q� Q� Q�Z�%�1�C�C�$�<�� D� 
� 
� 
� 
� 
� 
� 
� 
�
� 	�O�:�O�O�P�P�P�Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q� Q���� Q� Q� Q� Q� Q� Qs   �=?C�
C�C�__main__)
r   �asyncio�tinkoff.investr   r   �trading.tinkoff_clientr   r   �__name__�run� �    r   �<module>r#      s�   �� 	�	�	�	� ���� 8� 8� 8� 8� 8� 8� 8� 8� 0� 0� 0� 0� 0� 0�Q� Q� Q�$ �z����G�K���������� �r"   

========================================

=== app\bot\handlers\figi_handler.py ===

from telegram import Update, Message
from telegram.ext import ContextTypes
from telegram.helpers import escape_markdown
from tinkoff.invest import AsyncClient, InstrumentShort
import os
import logging

logger = logging.getLogger(__name__)

async def handle_figi_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        message = update.message or update.channel_post
        if not message or not message.text:
            return

        # Извлекаем название инструмента после команды figi
        parts = message.text.split(maxsplit=1)
        if len(parts) < 2:
            await message.reply_text("❌ Укажите название инструмента")
            return

        instrument_name = parts[1].strip()
        await process_figi_request(message, instrument_name)

    except Exception as e:
        logger.error(f"Error: {str(e)}", exc_info=True)
        await message.reply_text("⚠️ Ошибка обработки запроса")

async def process_figi_request(message: Message, instrument_name: str):
    try:
        token = os.getenv("TINKOFF_TOKEN")
        if not token:
            logger.error("TINKOFF_TOKEN not configured!")
            await message.reply_text("❌ Ошибка конфигурации")
            return

        async with AsyncClient(token) as client:
            # Ищем инструмент
            response = await client.instruments.find_instrument(query=instrument_name)
            
            if not response.instruments:
                await message.reply_text(f"❌ Инструмент '{escape_markdown(instrument_name, version=2)}' не найден")
                return

            # Берем первый результат и экранируем все поля
            instrument = response.instruments[0]
            safe_data = {
                'name': escape_markdown(instrument.name, version=2),
                'figi': escape_markdown(instrument.figi, version=2),
                'ticker': escape_markdown(instrument.ticker, version=2)
            }

            response_text = (
                f"🔍 *{safe_data['name']}*\n"
                f"FIGI: \`{safe_data['figi']}\`\n"
                f"Тикер: {safe_data['ticker']}"
            )
            
            await message.reply_text(response_text, parse_mode='MarkdownV2')

    except Exception as e:
        logger.error(f"API Error: {str(e)}", exc_info=True)
        await message.reply_text("⚠️ Ошибка подключения к брокеру")


========================================

=== app\bot\handlers\__init__.py ===

from .trade_handlers import handle_buy, handle_sell
from .balance_handler import handle_balance
from .figi_handler import handle_figi_message
from .position_handler import handle_positions



========================================

=== app\bot\handlers\balance_handler.py ===

from telegram import Update
from telegram.ext import ContextTypes
from trading.tinkoff_client import TinkoffClient
import os
import logging
import asyncio  

logger = logging.getLogger(__name__)

async def handle_balance(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        message = update.message or update.channel_post
        client = TinkoffClient(os.getenv("TINKOFF_TOKEN"), os.getenv("ACCOUNT_ID"))
        
        balance = await client.get_balance_async()
        logger.debug(f"Raw balance data: {balance}")
        
        await message.reply_text(f"💰 Баланс: {balance:.2f} RUB")
    except Exception as e:
        logger.error(f"Balance error: {str(e)}", exc_info=True)
        await message.reply_text("❌ Ошибка получения баланса")


========================================

=== app\bot\handlers\trade_handlers.py ===

# app/bot/handlers/trade_handlers.py
from telegram import Update
from telegram.ext import ContextTypes
import os
import logging
import asyncio
from decimal import Decimal
from trading.tinkoff_client import TinkoffClient, Position 
from trading.order_executor import OrderExecutor

logger = logging.getLogger(__name__)

class TradeError(Exception):
    pass

async def _process_trade_command(update: Update, context: ContextTypes.DEFAULT_TYPE, action: str):
    try:
        message = update.message or update.channel_post
        if not message or not message.text:
            return

        instrument = message.text.split()[1].upper()
        logger.info(f"Processing {action.upper()} command for {instrument}")

        tinkoff_token = os.getenv("TINKOFF_TOKEN")
        account_id = os.getenv("ACCOUNT_ID")
        
        client = TinkoffClient(tinkoff_token, account_id)
        executor = OrderExecutor(tinkoff_token, account_id)

        figi = await client.get_figi(instrument)
        if not figi:
            raise TradeError(f"Инструмент {instrument} не найден")

        positions = await client.get_positions_async()
        
        # Обработка buy/sell через единый метод execute_smart_order
        if action == 'buy':
            await _handle_trade_logic(
                client=client,
                executor=executor,
                figi=figi,
                instrument=instrument,
                positions=positions,
                direction='long',
                risk_percent=Decimal('0.4')  # 40% от баланса для лонга
            )
        elif action == 'sell':
            await _handle_trade_logic(
                client=client,
                executor=executor,
                figi=figi,
                instrument=instrument,
                positions=positions,
                direction='short',
                risk_percent=Decimal('0.3')  # 30% от баланса для шорта
            )

        await message.reply_text(f"✅ Операция {action.upper()} для {instrument} выполнена")

    except TradeError as e:
        await message.reply_text(f"⚠️ {str(e)}")
    except Exception as e:
        logger.error(f"Ошибка: {str(e)}", exc_info=True)
        await message.reply_text("❌ Ошибка выполнения операции")

async def _handle_trade_logic(
    client: TinkoffClient,
    executor: OrderExecutor,
    figi: str,
    instrument: str,
    positions: list[Position],
    direction: str,
    risk_percent: Decimal
):
    """Обновленная логика с учетом изменений в API"""
    try:
        # Проверяем противоположную позицию
        opposite_pos = next(
            (p for p in positions 
             if p.ticker == instrument 
             and p.direction != direction),
            None
        )
        
        # Закрываем противоположную позицию если есть
        if opposite_pos:
            logger.info(f"Closing {opposite_pos.direction} position: {opposite_pos.lots} lots")
            await executor.execute_smart_order(
                figi=figi,
                desired_direction=opposite_pos.direction,
                amount=Decimal(opposite_pos.lots),
                close_only=True
            )
            await asyncio.sleep(1)

        # Получаем обновленный баланс
        balance = await client.get_balance_async()
        if balance <= 0:
            raise TradeError("Недостаточно средств")

        # Выполняем основную операцию
        await executor.execute_smart_order(
            figi=figi,
            desired_direction=direction,
            amount=balance * risk_percent
        )

    except Exception as e:
        logger.error(f"Trade error ({direction}): {str(e)}", exc_info=True)
        raise TradeError(f"Ошибка {direction} операции: {str(e)}")

async def handle_buy(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await _process_trade_command(update, context, 'buy')

async def handle_sell(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await _process_trade_command(update, context, 'sell')

========================================

=== app\bot\handlers\init.py ===

from .balance_handler import handle_balance
from .figi_handler import handle_figi_message
from .trade_handlers import handle_buy, handle_sell
from .position_handler import handle_positions


========================================

=== app\bot\handlers\position_handler.py ===

from telegram import Update
from telegram.ext import ContextTypes
from trading.tinkoff_client import TinkoffClient
import os
import logging

logger = logging.getLogger(__name__)

async def handle_positions(update: Update, context: ContextTypes.DEFAULT_TYPE):
    message = update.message or update.channel_post  # Исправление ошибки NoneType
    if not message:
        return

    try:
        client = TinkoffClient(os.getenv("TINKOFF_TOKEN"), os.getenv("ACCOUNT_ID"))
        positions = await client.get_positions_async()

        if not positions:
            await message.reply_text("🔍 Нет открытых позиций")
            return

        response = "📊 Открытые позиции:\n\n"
        for pos in positions:
            response += f"• {pos.ticker}: {pos.lots} лотов ({pos.direction.upper()})\n"

        await message.reply_text(response)

    except Exception as e:
        logger.error(f"Ошибка: {str(e)}", exc_info=True)
        await message.reply_text("❌ Ошибка при получении позиций")


========================================

=== app\bot\__init__.py ===

# Упрощаем импорт
from .handlers import (
    handle_balance,
    handle_figi_message,
    handle_buy,
    handle_sell,
    handle_positions
)


========================================

=== app\bot\main.py ===

from telegram import Update
from telegram.ext import (
    ApplicationBuilder,
    ContextTypes,
    MessageHandler,
    CommandHandler,
    filters
)
from bot.handlers import (
    handle_balance,
    handle_figi_message,
    handle_buy,
    handle_sell,
    handle_positions
)
import os
import logging
import re
import asyncio

# Импортируем новый функционал
from trading.order_executor import OrderExecutor
from trading.order_watcher import OrderWatcher  # <-- новый модуль

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.error(f"Ошибка: {context.error}", exc_info=True)
    try:
        message = update.message or update.channel_post
        if message:
            await message.reply_text("⚠️ Произошла внутренняя ошибка")
    except Exception as e:
        logger.error(f"Ошибка в error_handler: {str(e)}")

def setup_handlers(application):
    # Balance handler
    application.add_handler(MessageHandler(
        filters.TEXT & filters.Regex(re.compile(r'^(баланс|balance)$', re.IGNORECASE)),
        handle_balance
    ))
    
    # FIGI info handler
    application.add_handler(MessageHandler(
        filters.TEXT & filters.Regex(re.compile(r'^figi\s+\w+', re.IGNORECASE)),
        handle_figi_message
    ))
    
    # Positions handler
    application.add_handler(MessageHandler(
        filters.TEXT & filters.Regex(re.compile(r'^(состояние|positions)$', re.IGNORECASE)),
        handle_positions
    ))
    
    # Buy/Sell handlers
    application.add_handler(MessageHandler(
        filters.TEXT & filters.Regex(re.compile(r'^buy\s+\w+', re.IGNORECASE)),
        handle_buy
    ))
    
    application.add_handler(MessageHandler(
        filters.TEXT & filters.Regex(re.compile(r'^sell\s+\w+', re.IGNORECASE)),
        handle_sell
    ))

def main():
    token = os.getenv("BOT_TOKEN")
    tinkoff_token = os.getenv("TINKOFF_TOKEN")
    account_id = os.getenv("ACCOUNT_ID")
    chat_id = os.getenv("TG_CHAT_ID")  # Новый параметр (можно задать в .env)

    if not token:
        raise ValueError("Не задан BOT_TOKEN")
    if not tinkoff_token or not account_id:
        raise ValueError("Не заданы TINKOFF_TOKEN или ACCOUNT_ID")

    # Создаём Telegram-бот
    application = ApplicationBuilder().token(token).build()
    setup_handlers(application)
    application.add_error_handler(error_handler)

    # Создаём исполнителя и вотчера
    executor = OrderExecutor(tinkoff_token, account_id)
    watcher = OrderWatcher(
        tinkoff_token,
        account_id,
        executor,
        tg_bot=application.bot,
        chat_id=chat_id
    )

    # Запускаем вотчер в отдельной задаче
    loop = asyncio.get_event_loop()
    loop.create_task(watcher.watch_trades())

    logger.info("Бот запущен")
    application.run_polling()

if __name__ == '__main__':
    main()


========================================

=== app\Dockerfile.last ===

FROM python:3.10-slim

WORKDIR /app

# Кэширование зависимостей
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt \\
    && pip install aiohttp

# Отдельно копируем только нужные файлы
COPY config.py .
COPY trading/ ./trading/

# Добавляем проверку работоспособности
RUN python -c "from trading.order_executor import OrderExecutor; print('Module imports OK')" \\
    || (echo "Import error!" && exit 1)

CMD ["python", "-m", "trading.order_executor", "app.bot.main"]


========================================

=== app\Dockerfile ===

FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
RUN pip install --upgrade tinkoff-investments
RUN pip install uuid
RUN pip install --upgrade protobuf

# Копируем всю структуру проекта
COPY . .

# Устанавливаем переменную окружения для Python
ENV PYTHONPATH="\${PYTHONPATH}:/app"
ENV PYTHONPATH "\${PYTHONPATH}:/app:/app/trading:/app/bot"

CMD ["python", "-m", "bot.main"]


========================================

=== app\redis_queue.py ===

import redis
from pydantic import BaseModel
import json
from config import Settings

settings = Settings()

class RedisQueue:
    def __init__(self):
        self.redis = redis.Redis.from_url(settings.REDIS_URL)
        self.channel = 'trading_signals'

    async def publish_signal(self, signal: dict):
        self.redis.publish(self.channel, json.dumps(signal))

    async def listen_signals(self, callback):
        pubsub = self.redis.pubsub()
        pubsub.subscribe(self.channel)
        for message in pubsub.listen():
            if message['type'] == 'message':
                callback(json.loads(message['data']))

class TradeSignal(BaseModel):
    action: str  # buy/sell/balance
    figi: str = "NG_FIGI"  # Замените на реальный FIGI
    quantity: int = 1
    user_id: int
    chat_id: int


========================================

=== app\__init__.py ===



========================================

=== app\requirements.txt ===

python-telegram-bot>=20.0
# tinkoff-investments  # Актуальная версия API
# tinkoff-investments>=0.2.0b1 
tinkoff-investments
pydantic-settings>=2.0
redis>=4.5.4
asyncpg>=0.28.0
apscheduler>=3.10.0
aiohttp>=3.8.0
async-timeout>=4.0.2
backoff==2.2.1
pydantic>=2.0
numpy>=1.22.0  # Для RiskManager


========================================

=== app\trading\order_watcher.py ===

import logging
from tinkoff.invest import AsyncClient
from tinkoff.invest.async_services import AsyncServices
from .order_executor import OrderExecutor

logger = logging.getLogger(__name__)


class OrderWatcher:
    def __init__(self, token: str, account_id: str, executor: OrderExecutor, tg_bot=None, chat_id=None):
        self.token = token
        self.account_id = account_id
        self.executor = executor
        self.tg_bot = tg_bot
        self.chat_id = chat_id

    async def watch_trades(self):
        async with AsyncClient(self.token) as client:
            stream: AsyncServices.TradesStream = client.trades_stream
            logger.info("OrderWatcher запущен: слушаем поток сделок...")

            async for event in stream.trades_stream(accounts=[self.account_id]):
                try:
                    if not event.order_trades:
                        continue

                    figi = event.order_trades.figi
                    order_id = event.order_trades.order_id

                    # ✅ Определяем причину по словарю executor'а
                    reason = self.executor.order_reasons.get(order_id, "Неизвестно")

                    # Проверяем позицию после сделки
                    pos_type, qty = await self.executor._get_current_position(client, figi)
                    if not pos_type or qty == 0:
                        await self.executor._cancel_all_stop_orders(client, figi)
                        await self.executor._cancel_all_limit_orders(client, figi)

                        msg = f"ℹ️ Позиция по {figi} закрыта ({reason}). Все стопы и лимиты сняты."
                        logger.info(msg)

                        if self.tg_bot and self.chat_id:
                            try:
                                await self.tg_bot.send_message(chat_id=self.chat_id, text=msg)
                            except Exception as e:
                                logger.error(f"Ошибка при отправке уведомления: {e}")

                except Exception as e:
                    logger.error(f"Ошибка обработки события в OrderWatcher: {e}", exc_info=True)


========================================

=== app\trading\order_executor.py ===

from tinkoff.invest import (
    AsyncClient,
    OrderDirection,
    OrderType,
    InstrumentIdType,
    MoneyValue,
    StopOrderType,
    StopOrderExpirationType
)
from decimal import Decimal
import logging
import asyncio
from typing import Optional, Tuple
from dataclasses import dataclass

logger = logging.getLogger(__name__)

@dataclass
class TradeError(Exception):
    message: str


class OrderExecutor:
    def __init__(
        self,
        token: str,
        account_id: str,
        risk_percentage: Decimal = Decimal('0.4'),
        stop_loss_percent: Decimal = Decimal('0.51'),
        take_profit_percent: Decimal = Decimal('1.9'),
    ):
        self.token = token
        self.account_id = account_id
        self.risk_percentage = risk_percentage
        self.stop_loss_percent = stop_loss_percent / 100
        self.take_profit_percent = take_profit_percent / 100

        # ✅ Здесь храним соответствие order_id → причина
        self.order_reasons: dict[str, str] = {}

    # ---------------------------
    # Вспомогательные методы
    # ---------------------------
    def _money_value_to_decimal(self, money: MoneyValue) -> Decimal:
        if money is None:
            return Decimal(0)
        return Decimal(money.units) + Decimal(money.nano) / Decimal(1e9)

    async def _get_current_price(self, client: AsyncClient, figi: str) -> Decimal:
        last_prices = await client.market_data.get_last_prices(figi=[figi])
        price = last_prices.last_prices[0].price
        return Decimal(price.units) + Decimal(price.nano) / Decimal(1e9)

    async def _get_current_position(self, client: AsyncClient, figi: str) -> Tuple[Optional[str], int]:
        positions = await client.operations.get_positions(account_id=self.account_id)
        for future in positions.futures:
            if future.figi == figi:
                quantity = getattr(future, 'balance', 0)
                if quantity > 0:
                    return 'long', abs(quantity)
                elif quantity < 0:
                    return 'short', abs(quantity)
        return None, 0

    async def _get_available_funds(self, client: AsyncClient) -> Decimal:
        portfolio = await client.operations.get_portfolio(account_id=self.account_id)
        return self._money_value_to_decimal(portfolio.total_amount_currencies)

    # ---------------------------
    # Отмена ордеров
    # ---------------------------
    async def _cancel_all_limit_orders(self, client: AsyncClient, figi: str):
        orders = await client.orders.get_orders(account_id=self.account_id)
        for order in orders.orders:
            if order.figi == figi and order.order_type == OrderType.ORDER_TYPE_LIMIT:
                await client.orders.cancel_order(account_id=self.account_id, order_id=order.order_id)

    async def _cancel_all_stop_orders(self, client: AsyncClient, figi: str):
        stops = await client.stop_orders.get_stop_orders(account_id=self.account_id)
        for so in stops.stop_orders:
            if so.figi == figi:
                await client.stop_orders.cancel_stop_order(account_id=self.account_id, stop_order_id=so.stop_order_id)

    # ---------------------------
    # Закрытие позиции
    # ---------------------------
    async def _close_position(self, client: AsyncClient, figi: str, position_type: str, quantity: int):
        await self._cancel_all_stop_orders(client, figi)
        await self._cancel_all_limit_orders(client, figi)

        direction = (
            OrderDirection.ORDER_DIRECTION_SELL if position_type == 'long'
            else OrderDirection.ORDER_DIRECTION_BUY
        )
        order = await self._execute_order(
            client=client,
            figi=figi,
            quantity=quantity,
            direction=direction,
            order_type=OrderType.ORDER_TYPE_MARKET
        )
        # ✅ Запоминаем причину
        self.order_reasons[order.order_id] = "MARKET"
        return order

    # ---------------------------
    # Выставление защитных ордеров
    # ---------------------------
    async def _place_protection_orders(self, client: AsyncClient, figi: str, direction: str, entry_price: Decimal, quantity: int):
        instrument = (await client.instruments.get_instrument_by(
            id_type=InstrumentIdType.INSTRUMENT_ID_TYPE_FIGI,
            id=figi
        )).instrument
        min_price_increment = self._money_value_to_decimal(instrument.min_price_increment)

        if direction == 'long':
            stop_price = entry_price * (Decimal(1) - self.stop_loss_percent)
            take_profit_price = entry_price * (Decimal(1) + self.take_profit_percent)
            stop_direction = OrderDirection.ORDER_DIRECTION_SELL
        else:
            stop_price = entry_price * (Decimal(1) + self.stop_loss_percent)
            take_profit_price = entry_price * (Decimal(1) - self.take_profit_percent)
            stop_direction = OrderDirection.ORDER_DIRECTION_BUY

        stop_price = (stop_price // min_price_increment) * min_price_increment
        take_profit_price = (take_profit_price // min_price_increment) * min_price_increment

        def decimal_to_money(value: Decimal) -> MoneyValue:
            units = int(value)
            nano = int((value - units) * Decimal('1e9'))
            return MoneyValue(units=units, nano=nano)

        stop_price_money = decimal_to_money(stop_price)
        tp_price_money = decimal_to_money(take_profit_price)

        # Стоп-лосс
        stop_order = await client.stop_orders.post_stop_order(
            figi=figi,
            quantity=quantity,
            direction=stop_direction,
            account_id=self.account_id,
            stop_price=stop_price_money,
            price=stop_price_money,
            stop_order_type=StopOrderType.STOP_ORDER_TYPE_STOP_LOSS,
            expiration_type=StopOrderExpirationType.STOP_ORDER_EXPIRATION_TYPE_GOOD_TILL_CANCEL
        )
        self.order_reasons[stop_order.stop_order_id] = "STOP_LOSS"

        # Тейк-профит лимитом
        tp_order = await client.orders.post_order(
            figi=figi,
            quantity=quantity,
            direction=stop_direction,
            account_id=self.account_id,
            order_type=OrderType.ORDER_TYPE_LIMIT,
            price=tp_price_money
        )
        self.order_reasons[tp_order.order_id] = "TAKE_PROFIT"

    # ---------------------------
    # Исполнение ордеров
    # ---------------------------
    async def _execute_order(self, client: AsyncClient, figi: str, quantity: int, direction: OrderDirection, order_type: OrderType):
        return await client.orders.post_order(
            figi=figi,
            quantity=quantity,
            direction=direction,
            account_id=self.account_id,
            order_type=order_type
        )

    async def execute_smart_order(self, figi: str, desired_direction: str, amount: Decimal, close_only: bool = False):
        async with AsyncClient(self.token) as client:
            current_pos_type, current_pos_qty = await self._get_current_position(client, figi)

            if close_only:
                if current_pos_type:
                    await self._close_position(client, figi, current_pos_type, current_pos_qty)
                    return
                raise TradeError("Нет позиции для закрытия")

            direction_enum = (
                OrderDirection.ORDER_DIRECTION_BUY if desired_direction == 'long'
                else OrderDirection.ORDER_DIRECTION_SELL
            )

            if current_pos_type and current_pos_type != desired_direction:
                await self._close_position(client, figi, current_pos_type, current_pos_qty)

            futures_margin = await client.instruments.get_futures_margin(figi=figi)
            margin_field = 'initial_margin_on_buy' if desired_direction == 'long' else 'initial_margin_on_sell'
            go_per_lot = self._money_value_to_decimal(getattr(futures_margin, margin_field))
            available_funds = await self._get_available_funds(client)
            quantity = int((available_funds * self.risk_percentage) // go_per_lot)
            if quantity < 1:
                raise TradeError("Недостаточно средств")

            order = await self._execute_order(client, figi, quantity, direction_enum, OrderType.ORDER_TYPE_MARKET)
            self.order_reasons[order.order_id] = "MARKET"

            entry_price = await self._get_current_price(client, figi)
            await self._place_protection_orders(client, figi, desired_direction, entry_price, quantity)


========================================

=== app\trading\__init__.py ===



========================================

=== app\trading\test_tinkoff.py ===

# test_tinkoff.py
from trading.tinkoff_client import TinkoffClient
import asyncio

async def main():
    client = TinkoffClient(os.getenv("TINKOFF_TOKEN"), os.getenv("ACCOUNT_ID"))
    
    # Тест поиска FIGI
    figi = await client.get_figi_by_ticker_async("AAPL")
    print(f"FIGI для AAPL: {figi}")
    
    # Тест ордера
    result = await client.place_market_order_async(figi, 1, "buy")
    print(f"Результат ордера: {result}")

asyncio.run(main())


========================================

=== app\trading\tinkoff_client.py ===

from dataclasses import dataclass
from tinkoff.invest import (
    AsyncClient,
    InstrumentResponse,        
    PortfolioResponse,
    InstrumentIdType,
    MoneyValue
)
from decimal import Decimal
from typing import List, Optional
import logging


logger = logging.getLogger(__name__)

@dataclass
class Position:
    figi: str
    ticker: str
    lots: int
    direction: str

class TinkoffClient:
    def __init__(self, token: str, account_id: str):
        self.token = token
        self.account_id = account_id
        self.RUB_FIGI = "BBG0013HGFT4"

    async def _get_ticker_by_figi(self, figi: str) -> Optional[str]:
        """Получает тикер инструмента по FIGI"""
        async with AsyncClient(self.token) as client:
            try:
                instrument: InstrumentResponse = await client.instruments.get_instrument_by(
                    id_type=InstrumentIdType.INSTRUMENT_ID_TYPE_FIGI,
                    id=figi
                )
                return instrument.instrument.ticker
            except Exception as e:
                logger.error(f"Ошибка получения тикера для FIGI {figi}: {str(e)}")
                return None

    async def get_margin_attributes(self):
        async with AsyncClient(self.token) as client:
            return await client.operations.get_margin_attributes(account_id=self.account_id)

    async def get_positions_async(self) -> List[Position]:
        async with AsyncClient(self.token) as client:
            response = await client.operations.get_positions(account_id=self.account_id)
            positions = []
            
            for fut in response.futures:
                # Проверка актуальных полей
                lots = abs(fut.balance) if hasattr(fut, 'balance') else abs(fut.quantity)
                direction = 'long' if (fut.balance > 0 if hasattr(fut, 'balance') else fut.quantity > 0) else 'short'
                
                ticker = await self._get_ticker_by_figi(fut.figi)
                if not ticker:
                    ticker = fut.figi  # Используем FIGI если тикер не найден
                    
                positions.append(Position(
                    ticker=ticker,
                    figi=fut.figi,
                    lots=lots,
                    direction=direction
                ))
            
            # Логирование для отладки
            logger.debug(f"Структура позиций: {response}")
            return positions

    async def get_balance_async(self) -> Decimal:
        async with AsyncClient(self.token) as client:
            try:
                # Получаем информацию по валютам
                positions = await client.operations.get_positions(account_id=self.account_id)
                logger.debug(f"Raw positions response: {positions}")
                
                rub_balance = Decimal(0)
                
                for money in positions.money:
                    if money.currency == 'rub':
                        rub_balance += self._money_value_to_decimal(money)
                
                # Обрабатываем ценные бумаги с балансом в RUB
                for security in positions.securities:
                    if security.blocked == 0 and security.balance > 0:
                        instrument = await self._get_instrument_by_figi(security.figi)
                        if instrument and instrument.currency == 'rub':
                            last_price = await self._get_last_price(client, security.figi)
                            rub_balance += last_price * security.balance
                
                logger.info(f"Calculated RUB balance: {rub_balance}")
                return rub_balance
                
            except Exception as e:
                logger.error(f"Balance calculation error: {str(e)}", exc_info=True)
                raise

    async def _get_instrument_by_figi(self, figi: str):
        async with AsyncClient(self.token) as client:
            return await client.instruments.get_instrument_by(
                id_type=InstrumentIdType.INSTRUMENT_ID_TYPE_FIGI,
                id=figi
            )

    async def _get_last_price(self, client: AsyncClient, figi: str) -> Decimal:
        last_price = await client.market_data.get_last_prices(figi=[figi])
        if last_price.last_prices:
            price = last_price.last_prices[0].price
            return Decimal(price.units) + Decimal(price.nano) / Decimal(1e9)
        return Decimal(0)

    def _calculate_available_funds(self, portfolio: PortfolioResponse) -> Decimal:
        cash = next(
            (pos for pos in portfolio.positions 
             if pos.figi == self.RUB_FIGI),
            None
        )
        return self._money_value_to_decimal(cash.current_price) if cash else Decimal(0)

    async def get_figi(self, instrument: str) -> Optional[str]:
        async with AsyncClient(self.token) as client:
            # Убрали некорректный параметр instrument_status
            response = await client.instruments.find_instrument(query=instrument)
            return response.instruments[0].figi if response.instruments else None


    @staticmethod
    def _money_value_to_decimal(money: MoneyValue) -> Decimal:
        """Конвертация MoneyValue в Decimal"""
        return Decimal(money.units) + Decimal(money.nano) / Decimal(1e9)


    async def get_balance_async(self) -> Decimal:
        """Получение доступного RUB баланса"""
        async with AsyncClient(self.token) as client:
            try:
                positions = await client.operations.get_positions(account_id=self.account_id)
                rub_balance = Decimal(0)
                
                # Обрабатываем только рублёвые позиции
                for money in positions.money:
                    if money.currency == 'rub':
                        rub_balance += self._money_value_to_decimal(money)
                
                logger.debug(f"Raw RUB balance: {rub_balance}")
                return rub_balance

            except Exception as e:
                logger.error(f"Balance error: {str(e)}", exc_info=True)
                raise

========================================

=== app\trading\init.py ===

from .tinkoff_client import TinkoffClient, Position
from .order_executor import OrderExecutor

__all__ = ['TinkoffClient', 'OrderExecutor', 'Position']


========================================

=== app\trading\models.py ===

from pydantic import BaseModel
from datetime import datetime

class TradeSignal(BaseModel):
    figi: str
    direction: str  # buy/sell
    quantity: int
    timestamp: datetime

class AccountBalance(BaseModel):
    total: float
    available: float
    currency: str
    updated_at: datetime

class InstrumentCache(BaseModel):
    ticker: str
    figi: str
    min_lot: int
    updated_at: datetime    


========================================

=== app\trading\risk_manager.py ===

from decimal import Decimal
from tinkoff.invest import AsyncClient, Quotation, InstrumentShort
from redis import Redis
import logging
from config import Settings

logger = logging.getLogger(__name__)

class RiskManager:
    def __init__(self, token: str, account_id: str):
        self.token = token
        self.account_id = account_id
        self.settings = Settings()
        self.redis = Redis.from_url(self.settings.REDIS_URL)
        self.cache_ttl = 86400  # 24 часа

    async def get_figi(self, instrument_name: str) -> str:
        """Поиск FIGI с кэшированием"""
        cache_key = f"figi:{instrument_name}"
        cached = self.redis.get(cache_key)
        
        if cached:
            return cached.decode()

        async with AsyncClient(self.token) as client:
            try:
                response = await client.instruments.find_instrument(query=instrument_name)
                for instrument in response.instruments:
                    if instrument.ticker.upper() == instrument_name.upper():
                        figi = instrument.figi
                        self.redis.setex(cache_key, self.cache_ttl, figi)
                        return figi
                raise ValueError(f"Инструмент {instrument_name} не найден")
            except Exception as e:
                logger.error(f"FIGI search error: {str(e)}")
                raise

    def _validate_min_lot(self, instrument: InstrumentShort, quantity: int):
        """Проверка минимального лота"""
        if not hasattr(instrument, 'min_quantity_increment') or instrument.min_quantity_increment is None:
            raise ValueError("Инструмент не имеет минимального лота")

        min_lot = instrument.min_quantity_increment
        if quantity < min_lot:
            raise ValueError(f"Количество {quantity} меньше минимального лота {min_lot}")

    async def validate_order(self, figi: str, quantity: int) -> dict:
        """Основная проверка перед исполнением ордера"""
        try:
            async with AsyncClient(self.token) as client:
                instrument = await client.instruments.get_instrument_by_figi(figi=figi)
                
                # Валидация минимального лота
                self._validate_min_lot(instrument, quantity)

                # Получение цены и расчет стоимости
                last_price = await self._get_last_price(client, figi)
                position_cost = last_price * quantity * instrument.lot

                # Получение доступного баланса
                portfolio = await client.operations.get_portfolio(account_id=self.account_id)
                total = portfolio.total_amount_portfolio
                available = self._quotation_to_decimal(total)

                # Проверки
                checks = {
                    'min_lot': quantity >= instrument.min_quantity_increment,
                    'balance': position_cost <= available * Decimal('0.5'),
                    'daily_limit': position_cost <= Decimal('100000'),
                    'instrument_active': instrument.api_trade_available_flag
                }

                return {
                    'status': 'approved' if all(checks.values()) else 'rejected',
                    'checks': checks
                }

        except Exception as e:
            logger.error(f"Risk validation error: {str(e)}")
            return {
                'status': 'error',
                'message': str(e),
                'checks': {}
            }

    async def _get_last_price(self, client: AsyncClient, figi: str) -> Decimal:
        """Получение последней цены"""
        order_book = await client.market_data.get_order_book(figi=figi, depth=1)
        return self._quotation_to_decimal(order_book.last_price)

    def _quotation_to_decimal(self, q: Quotation) -> Decimal:
        """Конвертация Quotation в Decimal"""
        return Decimal(q.units) + Decimal(q.nano) / 1e9


========================================

=== app\trading\__pycache__\__init__.cpython-311.pyc ===

�
    �4h    �                   �   � d S )N� r   �    �/app/trading/__init__.py�<module>r      s   �� � r   

========================================

=== app\trading\__pycache__\tinkoff_client.cpython-311.pyc ===

�
    �4h[  �                   �|   � d dl mZmZmZmZ d dlmZ d dlmZm	Z	 d dl
Z
 e
j        e�  �        Z G d� d�  �        ZdS )�    )�AsyncClient�PortfolioResponse�PositionsResponse�
MoneyValue)�Decimal)�List�OptionalNc                   �r   � e Zd Zdedefd�Zdefd�Zdedefd�Zdede	e         fd	�Z
edefd
��   �         ZdS )�TinkoffClient�token�
account_idc                 �0   � || _         || _        d| _        d S )N�BBG0013HGFT4)r   r   �RUB_FIGI)�selfr   r   s      �/app/trading/tinkoff_client.py�__init__zTinkoffClient.__init__   s   � ���
�$���&�����    �returnc              �   ��   K  � t          | j        �  �        4 �d {V ��}|j        �                    | j        ��  �        � d {V ��}| �                    |�  �        cd d d �  �        �d {V �� S # 1 �d {V ��swxY w Y   d S )N)r   )r   r   �
operations�get_portfolior   �_calculate_available_funds)r   �client�responses      r   �get_balance_asynczTinkoffClient.get_balance_async   s$  � � � ��t�z�*�*� 	=� 	=� 	=� 	=� 	=� 	=� 	=�f�#�.�<�<��?� =� � � � � � � � �H� �2�2�8�<�<�		=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=� 	=���� 	=� 	=� 	=� 	=� 	=� 	=s   �;A+�+
A5�8A5�	portfolioc                 �   � � t          � fd�|j        D �   �         d �  �        }|r� �                    |j        �  �        nt	          d�  �        S )Nc              3   �<   �K  � | ]}|j         �j        k    �|V � �d S )N)�figir   )�.0�posr   s     �r   �	<genexpr>z;TinkoffClient._calculate_available_funds.<locals>.<genexpr>   s=   �� � � � +� +�S���D�M�)�)� �)�)�)�)�+� +r   r   )�next�	positions�_money_value_to_decimal�current_pricer   )r   r   �cashs   `  r   r   z(TinkoffClient._calculate_available_funds   si   �� ��+� +� +� +�I�/� +� +� +��
� 
��
 DH�W�t�+�+�D�,>�?�?�?�W�UV�Z�Z�Wr   �
instrumentc              �   ��   K  � t          | j        �  �        4 �d {V ��}|j        �                    |��  �        � d {V ��}|j        r|j        d         j        nd cd d d �  �        �d {V �� S # 1 �d {V ��swxY w Y   d S )N)�queryr   )r   r   �instruments�find_instrumentr    )r   r)   r   r   s       r   �get_figizTinkoffClient.get_figi"   s<  � � � ��t�z�*�*� 	R� 	R� 	R� 	R� 	R� 	R� 	R�f�#�/�?�?�j�?�Q�Q�Q�Q�Q�Q�Q�Q�H�3;�3G�Q�8�'��*�/�/�T�	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R� 	R���� 	R� 	R� 	R� 	R� 	R� 	Rs   �<A,�,
A6�9A6c                 ��   � t          | d�  �        rIt          | d�  �        r9t          | j        �  �        t          | j        �  �        t          d�  �        z  z   S t          d�  �        S )N�units�nanoi ʚ;r   )�hasattrr   r0   r1   )�moneys    r   r&   z%TinkoffClient._money_value_to_decimal(   s]   � ��5�'�"�"� 	O�w�u�f�'=�'=� 	O��5�;�'�'�'�%�*�*=�*=�����*N�N�N��q�z�z�r   N)�__name__�
__module__�__qualname__�strr   r   r   r   r   r	   r.   �staticmethodr&   � r   r   r   r      s�   � � � � � �'�c� '�s� '� '� '� '�
=�� =� =� =� =�X�4E� X�'� X� X� X� X�R�� R��#�� R� R� R� R� ��'� � � � �\�� � r   r   )�tinkoff.investr   r   r   r   �decimalr   �typingr   r	   �logging�	getLoggerr4   �loggerr   r9   r   r   �<module>r@      s�   ��� � � � � � � � � � � � � � � � � � !� !� !� !� !� !� !� !� ����	��	�8�	$�	$��� � � � � � � � � r   

========================================

=== app\notifications.py ===

from telegram import Bot
import logging

logger = logging.getLogger(__name__)

class Notifier:
    def __init__(self, token: str, chat_id: int):
        self.bot = Bot(token=token)
        self.chat_id = chat_id

    def send_order_confirmation(self, order_details: dict):
        message = (
            f"🔄 Ордер исполнен:\\n"
            f"FIGI: {order_details.figi}\\n"
            f"Направление: {order_details.direction}\\n"
            f"Количество: {order_details.quantity}\\n"
            f"Цена: {order_details.executed_price}"
        )
        self.bot.send_message(chat_id=self.chat_id, text=message)


========================================

=== docker-compose.yml ===

version: '3.8'

services:
  bot:
    build: ./app
    command: python -m bot.main
    env_file: .env
    environment:
      - BOT_TOKEN=${BOT_TOKEN}
      - TARGET_USER_ID=${TARGET_USER_ID}
    restart: unless-stopped
    depends_on:
      - redis
      - db

  redis:
    image: redis:alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  db:
    image: postgres:13
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 5s
      timeout: 5s
      retries: 10
    volumes:
      - postgres_data:/var/lib/postgresql/data        

volumes:
  redis_data:
  postgres_data:


========================================

=== .gitignore ===

.env
*.sh
*.info
*.proj
.*
proj.*
backup.*
backup*
save*
*workly
temp
trader*
*.pyc
__pycache__


========================================

=== db\init.sql ===

CREATE TABLE IF NOT EXISTS trades (
    id SERIAL PRIMARY KEY,
    figi VARCHAR(20) NOT NULL,
    direction VARCHAR(4) NOT NULL,
    quantity INTEGER NOT NULL,
    price NUMERIC(12,4) NOT NULL,
    executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS balance_history (
    id SERIAL PRIMARY KEY,
    account_id VARCHAR(20) NOT NULL,
    balance NUMERIC(12,4) NOT NULL,
    recorded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO bot;

CREATE INDEX idx_trades_figi ON trades(figi);
CREATE INDEX idx_balance_account ON balance_history(account_id);


========================================



========================================

=== db\init.sql ===

CREATE TABLE IF NOT EXISTS trades (
    id SERIAL PRIMARY KEY,
    figi VARCHAR(20) NOT NULL,
    direction VARCHAR(4) NOT NULL,
    quantity INTEGER NOT NULL,
    price NUMERIC(12,4) NOT NULL,
    executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS balance_history (
    id SERIAL PRIMARY KEY,
    account_id VARCHAR(20) NOT NULL,
    balance NUMERIC(12,4) NOT NULL,
    recorded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO bot;

CREATE INDEX idx_trades_figi ON trades(figi);
CREATE INDEX idx_balance_account ON balance_history(account_id);


========================================

