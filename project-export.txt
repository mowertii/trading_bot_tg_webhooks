PROJECT EXPORT

PROJECT STRUCTURE:

ğŸ“ app
  ğŸ“ bot
    ğŸ“ handlers
      ğŸ“„ __init__.py
      ğŸ“„ balance_handler.py
      ğŸ“„ figi_handler.py
      ğŸ“„ init.py
      ğŸ“„ position_handler.py
      ğŸ“„ trade_handlers.py
    ğŸ“„ __init__.py
    ğŸ“„ main.py
  ğŸ“ scripts
    ğŸ“ __pycache__
      ğŸ“„ tinkoff_check.cpython-311.pyc
    ğŸ“„ tinkoff_check.py
  ğŸ“ trading
    ğŸ“ __pycache__
      ğŸ“„ __init__.cpython-311.pyc
      ğŸ“„ tinkoff_client.cpython-311.pyc
    ğŸ“„ __init__.py
    ğŸ“„ init.py
    ğŸ“„ models.py
    ğŸ“„ order_executor.py
    ğŸ“„ order_watcher.py
    ğŸ“„ risk_manager.py
    ğŸ“„ test_tinkoff.py
    ğŸ“„ tinkoff_client.py
  ğŸ“„ __init__.py
  ğŸ“„ config.py
  ğŸ“„ Dockerfile
  ğŸ“„ Dockerfile.last
  ğŸ“„ notifications.py
  ğŸ“„ redis_queue.py
  ğŸ“„ requirements.txt
ğŸ“ db
  ğŸ“„ init.sql
ğŸ“„ .env
ğŸ“„ .gitignore
ğŸ“„ docker-compose.yml
ğŸ“„ project-export.txt

FILES:

=== .env ===

BOT_TOKEN=7627503533:AAHJuYt3Bh7k-Y0SyOEeujPJ_4wjMj8c555
TARGET_USER_ID=1822765755
TINKOFF_TOKEN=t.cEGrGB9IbFCVpLzEO94lOx0_n0av3Nwq0pAWhVmpMIR27-bI8pPjomMZiOSuRzScDUyt7XwTMKkFvhfuMpQ555
ACCOUNT_ID=2213960479
REDIS_URL=redis://redis:6379/0
POSTGRES_DB=trading_data  # Ğ”Ğ¾Ğ»Ğ¶Ğ½Ğ¾ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´Ğ°Ñ‚ÑŒ Ñ Ğ¸Ğ¼ĞµĞ½ĞµĞ¼ Ğ¸Ğ· docker-compose
POSTGRES_USER=bot
POSTGRES_PASSWORD=11111111
DB_URL=postgresql://bot:11111111@db:5432/trading_data


========================================

=== app\config.py ===

# config.py
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    BOT_TOKEN = os.getenv("BOT_TOKEN")
    TINKOFF_TOKEN = os.getenv("TINKOFF_TOKEN")
    ACCOUNT_ID = os.getenv("ACCOUNT_ID")
    LOG_LEVEL = os.getenv("LOG_LEVEL", "DEBUG")    


========================================

=== app\scripts\tinkoff_check.py ===

import os
import asyncio
from tinkoff.invest import AsyncClient, InstrumentIdType
from trading.tinkoff_client import TinkoffClient

async def main():
    token = os.getenv("TINKOFF_TOKEN")
    account_id = os.getenv("ACCOUNT_ID")
    
    client = TinkoffClient(token, account_id)
    
    # Ğ¢ĞµÑÑ‚ Ğ¿Ğ¾Ğ¸ÑĞºĞ° FIGI
    figi = await client.get_figi_by_ticker("SBER")
    print(f"FIGI Ğ´Ğ»Ñ SBER: {figi}")
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ğ°
    async with AsyncClient(token) as api_client:
        instrument = await api_client.instruments.get_instrument_by(
            id_type=InstrumentIdType.INSTRUMENT_ID_TYPE_FIGI,
            id=figi
        )
        print(f"Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ± Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ğµ: {instrument}")

if __name__ == "__main__":
    asyncio.run(main())

========================================

=== app\scripts\__pycache__\tinkoff_check.cpython-311.pyc ===

ï¿½
    ï¿½0h"  ï¿½                   ï¿½x   ï¿½ d dl Z d dlZd dlmZmZ d dlmZ dï¿½ Zedk    r ej	         eï¿½   ï¿½         ï¿½  ï¿½         dS dS )ï¿½    N)ï¿½AsyncClientï¿½InstrumentIdType)ï¿½TinkoffClientc               ï¿½   ï¿½ï¿½  K  ï¿½ t          j        dï¿½  ï¿½        } t          j        dï¿½  ï¿½        }t          | |ï¿½  ï¿½        }|ï¿½                    dï¿½  ï¿½        ï¿½ d {V ï¿½ï¿½}t	          d|ï¿½ ï¿½ï¿½  ï¿½         t          | ï¿½  ï¿½        4 ï¿½d {V ï¿½ï¿½}|j        ï¿½                    t          j	        |ï¿½ï¿½  ï¿½        ï¿½ d {V ï¿½ï¿½}t	          d|ï¿½ ï¿½ï¿½  ï¿½         d d d ï¿½  ï¿½        ï¿½d {V ï¿½ï¿½ d S # 1 ï¿½d {V ï¿½ï¿½swxY w Y   d S )Nï¿½TINKOFF_TOKENï¿½
ACCOUNT_IDï¿½SBERu   FIGI Ğ´Ğ»Ñ SBER: )ï¿½id_typeï¿½idu2   Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ± Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ğµ: )
ï¿½osï¿½getenvr   ï¿½get_figi_by_tickerï¿½printr   ï¿½instrumentsï¿½get_instrument_byr   ï¿½INSTRUMENT_ID_TYPE_FIGI)ï¿½tokenï¿½
account_idï¿½clientï¿½figiï¿½
api_clientï¿½
instruments         ï¿½/app/scripts/tinkoff_check.pyï¿½mainr      sï¿½  ï¿½ ï¿½ ï¿½ ï¿½ï¿½Iï¿½oï¿½&ï¿½&ï¿½Eï¿½ï¿½ï¿½<ï¿½(ï¿½(ï¿½Jï¿½ï¿½5ï¿½*ï¿½-ï¿½-ï¿½Fï¿½ ï¿½*ï¿½*ï¿½6ï¿½2ï¿½2ï¿½2ï¿½2ï¿½2ï¿½2ï¿½2ï¿½2ï¿½Dï¿½	ï¿½
%ï¿½tï¿½
%ï¿½
%ï¿½&ï¿½&ï¿½&ï¿½ ï¿½5ï¿½!ï¿½!ï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½Zï¿½%ï¿½1ï¿½Cï¿½Cï¿½$ï¿½<ï¿½ï¿½ Dï¿½ 
ï¿½ 
ï¿½ 
ï¿½ 
ï¿½ 
ï¿½ 
ï¿½ 
ï¿½ 
ï¿½
ï¿½ 	ï¿½Oï¿½:ï¿½Oï¿½Oï¿½Pï¿½Pï¿½Pï¿½Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ï¿½ï¿½ï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qs   ï¿½=?Cï¿½
Cï¿½Cï¿½__main__)
r   ï¿½asyncioï¿½tinkoff.investr   r   ï¿½trading.tinkoff_clientr   r   ï¿½__name__ï¿½runï¿½ ï¿½    r   ï¿½<module>r#      sï¿½   ï¿½ï¿½ 	ï¿½	ï¿½	ï¿½	ï¿½ ï¿½ï¿½ï¿½ï¿½ 8ï¿½ 8ï¿½ 8ï¿½ 8ï¿½ 8ï¿½ 8ï¿½ 8ï¿½ 8ï¿½ 0ï¿½ 0ï¿½ 0ï¿½ 0ï¿½ 0ï¿½ 0ï¿½Qï¿½ Qï¿½ Qï¿½$ ï¿½zï¿½ï¿½ï¿½ï¿½Gï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½r"   

========================================

=== app\bot\handlers\figi_handler.py ===

from telegram import Update, Message
from telegram.ext import ContextTypes
from telegram.helpers import escape_markdown
from tinkoff.invest import AsyncClient, InstrumentShort
import os
import logging

logger = logging.getLogger(__name__)

async def handle_figi_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        message = update.message or update.channel_post
        if not message or not message.text:
            return

        # Ğ˜Ğ·Ğ²Ğ»ĞµĞºĞ°ĞµĞ¼ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ğ° Ğ¿Ğ¾ÑĞ»Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹ figi
        parts = message.text.split(maxsplit=1)
        if len(parts) < 2:
            await message.reply_text("âŒ Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ğ°")
            return

        instrument_name = parts[1].strip()
        await process_figi_request(message, instrument_name)

    except Exception as e:
        logger.error(f"Error: {str(e)}", exc_info=True)
        await message.reply_text("âš ï¸ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ°")

async def process_figi_request(message: Message, instrument_name: str):
    try:
        token = os.getenv("TINKOFF_TOKEN")
        if not token:
            logger.error("TINKOFF_TOKEN not configured!")
            await message.reply_text("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ğ¸")
            return

        async with AsyncClient(token) as client:
            # Ğ˜Ñ‰ĞµĞ¼ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚
            response = await client.instruments.find_instrument(query=instrument_name)
            
            if not response.instruments:
                await message.reply_text(f"âŒ Ğ˜Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚ '{escape_markdown(instrument_name, version=2)}' Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½")
                return

            # Ğ‘ĞµÑ€ĞµĞ¼ Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¹ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚ Ğ¸ ÑĞºÑ€Ğ°Ğ½Ğ¸Ñ€ÑƒĞµĞ¼ Ğ²ÑĞµ Ğ¿Ğ¾Ğ»Ñ
            instrument = response.instruments[0]
            safe_data = {
                'name': escape_markdown(instrument.name, version=2),
                'figi': escape_markdown(instrument.figi, version=2),
                'ticker': escape_markdown(instrument.ticker, version=2)
            }

            response_text = (
                f"ğŸ” *{safe_data['name']}*\n"
                f"FIGI: \`{safe_data['figi']}\`\n"
                f"Ğ¢Ğ¸ĞºĞµÑ€: {safe_data['ticker']}"
            )
            
            await message.reply_text(response_text, parse_mode='MarkdownV2')

    except Exception as e:
        logger.error(f"API Error: {str(e)}", exc_info=True)
        await message.reply_text("âš ï¸ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ Ğº Ğ±Ñ€Ğ¾ĞºĞµÑ€Ñƒ")


========================================

=== app\bot\handlers\__init__.py ===

from .trade_handlers import handle_buy, handle_sell
from .balance_handler import handle_balance
from .figi_handler import handle_figi_message
from .position_handler import handle_positions



========================================

=== app\bot\handlers\balance_handler.py ===

from telegram import Update
from telegram.ext import ContextTypes
from trading.tinkoff_client import TinkoffClient
import os
import logging
import asyncio  

logger = logging.getLogger(__name__)

async def handle_balance(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        message = update.message or update.channel_post
        client = TinkoffClient(os.getenv("TINKOFF_TOKEN"), os.getenv("ACCOUNT_ID"))
        
        balance = await client.get_balance_async()
        logger.debug(f"Raw balance data: {balance}")
        
        await message.reply_text(f"ğŸ’° Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: {balance:.2f} RUB")
    except Exception as e:
        logger.error(f"Balance error: {str(e)}", exc_info=True)
        await message.reply_text("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ°")


========================================

=== app\bot\handlers\trade_handlers.py ===

# app/bot/handlers/trade_handlers.py
from telegram import Update
from telegram.ext import ContextTypes
import os
import logging
import asyncio
from decimal import Decimal
from trading.tinkoff_client import TinkoffClient, Position 
from trading.order_executor import OrderExecutor

logger = logging.getLogger(__name__)

class TradeError(Exception):
    pass

async def _process_trade_command(update: Update, context: ContextTypes.DEFAULT_TYPE, action: str):
    try:
        message = update.message or update.channel_post
        if not message or not message.text:
            return

        instrument = message.text.split()[1].upper()
        logger.info(f"Processing {action.upper()} command for {instrument}")

        tinkoff_token = os.getenv("TINKOFF_TOKEN")
        account_id = os.getenv("ACCOUNT_ID")
        
        client = TinkoffClient(tinkoff_token, account_id)
        executor = OrderExecutor(tinkoff_token, account_id)

        figi = await client.get_figi(instrument)
        if not figi:
            raise TradeError(f"Ğ˜Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚ {instrument} Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½")

        positions = await client.get_positions_async()
        
        # ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° buy/sell Ñ‡ĞµÑ€ĞµĞ· ĞµĞ´Ğ¸Ğ½Ñ‹Ğ¹ Ğ¼ĞµÑ‚Ğ¾Ğ´ execute_smart_order
        if action == 'buy':
            await _handle_trade_logic(
                client=client,
                executor=executor,
                figi=figi,
                instrument=instrument,
                positions=positions,
                direction='long',
                risk_percent=Decimal('0.4')  # 40% Ğ¾Ñ‚ Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ° Ğ´Ğ»Ñ Ğ»Ğ¾Ğ½Ğ³Ğ°
            )
        elif action == 'sell':
            await _handle_trade_logic(
                client=client,
                executor=executor,
                figi=figi,
                instrument=instrument,
                positions=positions,
                direction='short',
                risk_percent=Decimal('0.3')  # 30% Ğ¾Ñ‚ Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ° Ğ´Ğ»Ñ ÑˆĞ¾Ñ€Ñ‚Ğ°
            )

        await message.reply_text(f"âœ… ĞĞ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ {action.upper()} Ğ´Ğ»Ñ {instrument} Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ°")

    except TradeError as e:
        await message.reply_text(f"âš ï¸ {str(e)}")
    except Exception as e:
        logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)}", exc_info=True)
        await message.reply_text("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸")

async def _handle_trade_logic(
    client: TinkoffClient,
    executor: OrderExecutor,
    figi: str,
    instrument: str,
    positions: list[Position],
    direction: str,
    risk_percent: Decimal
):
    """ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ğ°Ñ Ğ»Ğ¾Ğ³Ğ¸ĞºĞ° Ñ ÑƒÑ‡ĞµÑ‚Ğ¾Ğ¼ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¹ Ğ² API"""
    try:
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶Ğ½ÑƒÑ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ
        opposite_pos = next(
            (p for p in positions 
             if p.ticker == instrument 
             and p.direction != direction),
            None
        )
        
        # Ğ—Ğ°ĞºÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶Ğ½ÑƒÑ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ ĞµÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ
        if opposite_pos:
            logger.info(f"Closing {opposite_pos.direction} position: {opposite_pos.lots} lots")
            await executor.execute_smart_order(
                figi=figi,
                desired_direction=opposite_pos.direction,
                amount=Decimal(opposite_pos.lots),
                close_only=True
            )
            await asyncio.sleep(1)

        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ
        balance = await client.get_balance_async()
        if balance <= 0:
            raise TradeError("ĞĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ ÑÑ€ĞµĞ´ÑÑ‚Ğ²")

        # Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞµĞ¼ Ğ¾ÑĞ½Ğ¾Ğ²Ğ½ÑƒÑ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ
        await executor.execute_smart_order(
            figi=figi,
            desired_direction=direction,
            amount=balance * risk_percent
        )

    except Exception as e:
        logger.error(f"Trade error ({direction}): {str(e)}", exc_info=True)
        raise TradeError(f"ĞÑˆĞ¸Ğ±ĞºĞ° {direction} Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸: {str(e)}")

async def handle_buy(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await _process_trade_command(update, context, 'buy')

async def handle_sell(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await _process_trade_command(update, context, 'sell')

========================================

=== app\bot\handlers\init.py ===

from .balance_handler import handle_balance
from .figi_handler import handle_figi_message
from .trade_handlers import handle_buy, handle_sell
from .position_handler import handle_positions


========================================

=== app\bot\handlers\position_handler.py ===

from telegram import Update
from telegram.ext import ContextTypes
from trading.tinkoff_client import TinkoffClient
import os
import logging

logger = logging.getLogger(__name__)

async def handle_positions(update: Update, context: ContextTypes.DEFAULT_TYPE):
    message = update.message or update.channel_post  # Ğ˜ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸ NoneType
    if not message:
        return

    try:
        client = TinkoffClient(os.getenv("TINKOFF_TOKEN"), os.getenv("ACCOUNT_ID"))
        positions = await client.get_positions_async()

        if not positions:
            await message.reply_text("ğŸ” ĞĞµÑ‚ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¹")
            return

        response = "ğŸ“Š ĞÑ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸:\n\n"
        for pos in positions:
            response += f"â€¢ {pos.ticker}: {pos.lots} Ğ»Ğ¾Ñ‚Ğ¾Ğ² ({pos.direction.upper()})\n"

        await message.reply_text(response)

    except Exception as e:
        logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)}", exc_info=True)
        await message.reply_text("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğ¸ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¹")


========================================

=== app\bot\__init__.py ===

# Ğ£Ğ¿Ñ€Ğ¾Ñ‰Ğ°ĞµĞ¼ Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚
from .handlers import (
    handle_balance,
    handle_figi_message,
    handle_buy,
    handle_sell,
    handle_positions
)


========================================

=== app\bot\main.py ===

from telegram import Update
from telegram.ext import (
    ApplicationBuilder,
    ContextTypes,
    MessageHandler,
    CommandHandler,
    filters
)
from bot.handlers import (
    handle_balance,
    handle_figi_message,
    handle_buy,
    handle_sell,
    handle_positions
)
import os
import logging
import re
import asyncio

# Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¾Ğ½Ğ°Ğ»
from trading.order_executor import OrderExecutor
from trading.order_watcher import OrderWatcher  # <-- Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ¼Ğ¾Ğ´ÑƒĞ»ÑŒ

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ°: {context.error}", exc_info=True)
    try:
        message = update.message or update.channel_post
        if message:
            await message.reply_text("âš ï¸ ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ²Ğ½ÑƒÑ‚Ñ€ĞµĞ½Ğ½ÑÑ Ğ¾ÑˆĞ¸Ğ±ĞºĞ°")
    except Exception as e:
        logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ² error_handler: {str(e)}")

def setup_handlers(application):
    # Balance handler
    application.add_handler(MessageHandler(
        filters.TEXT & filters.Regex(re.compile(r'^(Ğ±Ğ°Ğ»Ğ°Ğ½Ñ|balance)$', re.IGNORECASE)),
        handle_balance
    ))
    
    # FIGI info handler
    application.add_handler(MessageHandler(
        filters.TEXT & filters.Regex(re.compile(r'^figi\s+\w+', re.IGNORECASE)),
        handle_figi_message
    ))
    
    # Positions handler
    application.add_handler(MessageHandler(
        filters.TEXT & filters.Regex(re.compile(r'^(ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ|positions)$', re.IGNORECASE)),
        handle_positions
    ))
    
    # Buy/Sell handlers
    application.add_handler(MessageHandler(
        filters.TEXT & filters.Regex(re.compile(r'^buy\s+\w+', re.IGNORECASE)),
        handle_buy
    ))
    
    application.add_handler(MessageHandler(
        filters.TEXT & filters.Regex(re.compile(r'^sell\s+\w+', re.IGNORECASE)),
        handle_sell
    ))

def main():
    token = os.getenv("BOT_TOKEN")
    tinkoff_token = os.getenv("TINKOFF_TOKEN")
    account_id = os.getenv("ACCOUNT_ID")
    chat_id = os.getenv("TG_CHAT_ID")  # ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€ (Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ·Ğ°Ğ´Ğ°Ñ‚ÑŒ Ğ² .env)

    if not token:
        raise ValueError("ĞĞµ Ğ·Ğ°Ğ´Ğ°Ğ½ BOT_TOKEN")
    if not tinkoff_token or not account_id:
        raise ValueError("ĞĞµ Ğ·Ğ°Ğ´Ğ°Ğ½Ñ‹ TINKOFF_TOKEN Ğ¸Ğ»Ğ¸ ACCOUNT_ID")

    # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Telegram-Ğ±Ğ¾Ñ‚
    application = ApplicationBuilder().token(token).build()
    setup_handlers(application)
    application.add_error_handler(error_handler)

    # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ğ¸ÑĞ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»Ñ Ğ¸ Ğ²Ğ¾Ñ‚Ñ‡ĞµÑ€Ğ°
    executor = OrderExecutor(tinkoff_token, account_id)
    watcher = OrderWatcher(
        tinkoff_token,
        account_id,
        executor,
        tg_bot=application.bot,
        chat_id=chat_id
    )

    # Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ğ²Ğ¾Ñ‚Ñ‡ĞµÑ€ Ğ² Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ğ¾Ğ¹ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğµ
    loop = asyncio.get_event_loop()
    loop.create_task(watcher.watch_trades())

    logger.info("Ğ‘Ğ¾Ñ‚ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½")
    application.run_polling()

if __name__ == '__main__':
    main()


========================================

=== app\Dockerfile.last ===

FROM python:3.10-slim

WORKDIR /app

# ĞšÑÑˆĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt \\
    && pip install aiohttp

# ĞÑ‚Ğ´ĞµĞ»ÑŒĞ½Ğ¾ ĞºĞ¾Ğ¿Ğ¸Ñ€ÑƒĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ½ÑƒĞ¶Ğ½Ñ‹Ğµ Ñ„Ğ°Ğ¹Ğ»Ñ‹
COPY config.py .
COPY trading/ ./trading/

# Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºÑƒ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ¾ÑĞ¿Ğ¾ÑĞ¾Ğ±Ğ½Ğ¾ÑÑ‚Ğ¸
RUN python -c "from trading.order_executor import OrderExecutor; print('Module imports OK')" \\
    || (echo "Import error!" && exit 1)

CMD ["python", "-m", "trading.order_executor", "app.bot.main"]


========================================

=== app\Dockerfile ===

FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
RUN pip install --upgrade tinkoff-investments
RUN pip install uuid
RUN pip install --upgrade protobuf

# ĞšĞ¾Ğ¿Ğ¸Ñ€ÑƒĞµĞ¼ Ğ²ÑÑ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñƒ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°
COPY . .

# Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½ÑƒÑ Ğ¾ĞºÑ€ÑƒĞ¶ĞµĞ½Ğ¸Ñ Ğ´Ğ»Ñ Python
ENV PYTHONPATH="\${PYTHONPATH}:/app"
ENV PYTHONPATH "\${PYTHONPATH}:/app:/app/trading:/app/bot"

CMD ["python", "-m", "bot.main"]


========================================

=== app\redis_queue.py ===

import redis
from pydantic import BaseModel
import json
from config import Settings

settings = Settings()

class RedisQueue:
    def __init__(self):
        self.redis = redis.Redis.from_url(settings.REDIS_URL)
        self.channel = 'trading_signals'

    async def publish_signal(self, signal: dict):
        self.redis.publish(self.channel, json.dumps(signal))

    async def listen_signals(self, callback):
        pubsub = self.redis.pubsub()
        pubsub.subscribe(self.channel)
        for message in pubsub.listen():
            if message['type'] == 'message':
                callback(json.loads(message['data']))

class TradeSignal(BaseModel):
    action: str  # buy/sell/balance
    figi: str = "NG_FIGI"  # Ğ—Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚Ğµ Ğ½Ğ° Ñ€ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ FIGI
    quantity: int = 1
    user_id: int
    chat_id: int


========================================

=== app\__init__.py ===



========================================

=== app\requirements.txt ===

python-telegram-bot>=20.0
# tinkoff-investments  # ĞĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ğ°Ñ Ğ²ĞµÑ€ÑĞ¸Ñ API
# tinkoff-investments>=0.2.0b1 
tinkoff-investments
pydantic-settings>=2.0
redis>=4.5.4
asyncpg>=0.28.0
apscheduler>=3.10.0
aiohttp>=3.8.0
async-timeout>=4.0.2
backoff==2.2.1
pydantic>=2.0
numpy>=1.22.0  # Ğ”Ğ»Ñ RiskManager


========================================

=== app\trading\order_watcher.py ===

import logging
from tinkoff.invest import AsyncClient
from tinkoff.invest.async_services import AsyncServices
from .order_executor import OrderExecutor

logger = logging.getLogger(__name__)


class OrderWatcher:
    def __init__(self, token: str, account_id: str, executor: OrderExecutor, tg_bot=None, chat_id=None):
        self.token = token
        self.account_id = account_id
        self.executor = executor
        self.tg_bot = tg_bot
        self.chat_id = chat_id

    async def watch_trades(self):
        async with AsyncClient(self.token) as client:
            stream: AsyncServices.TradesStream = client.trades_stream
            logger.info("OrderWatcher Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½: ÑĞ»ÑƒÑˆĞ°ĞµĞ¼ Ğ¿Ğ¾Ñ‚Ğ¾Ğº ÑĞ´ĞµĞ»Ğ¾Ğº...")

            async for event in stream.trades_stream(accounts=[self.account_id]):
                try:
                    if not event.order_trades:
                        continue

                    figi = event.order_trades.figi
                    order_id = event.order_trades.order_id

                    # âœ… ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼ Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ñƒ Ğ¿Ğ¾ ÑĞ»Ğ¾Ğ²Ğ°Ñ€Ñ executor'Ğ°
                    reason = self.executor.order_reasons.get(order_id, "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")

                    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ¿Ğ¾ÑĞ»Ğµ ÑĞ´ĞµĞ»ĞºĞ¸
                    pos_type, qty = await self.executor._get_current_position(client, figi)
                    if not pos_type or qty == 0:
                        await self.executor._cancel_all_stop_orders(client, figi)
                        await self.executor._cancel_all_limit_orders(client, figi)

                        msg = f"â„¹ï¸ ĞŸĞ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ¿Ğ¾ {figi} Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ° ({reason}). Ğ’ÑĞµ ÑÑ‚Ğ¾Ğ¿Ñ‹ Ğ¸ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ñ‹ ÑĞ½ÑÑ‚Ñ‹."
                        logger.info(msg)

                        if self.tg_bot and self.chat_id:
                            try:
                                await self.tg_bot.send_message(chat_id=self.chat_id, text=msg)
                            except Exception as e:
                                logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞµ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ: {e}")

                except Exception as e:
                    logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ Ğ² OrderWatcher: {e}", exc_info=True)


========================================

=== app\trading\order_executor.py ===

from tinkoff.invest import (
    AsyncClient,
    OrderDirection,
    OrderType,
    InstrumentIdType,
    MoneyValue,
    StopOrderType,
    StopOrderExpirationType
)
from decimal import Decimal
import logging
import asyncio
from typing import Optional, Tuple
from dataclasses import dataclass

logger = logging.getLogger(__name__)

@dataclass
class TradeError(Exception):
    message: str


class OrderExecutor:
    def __init__(
        self,
        token: str,
        account_id: str,
        risk_percentage: Decimal = Decimal('0.4'),
        stop_loss_percent: Decimal = Decimal('0.51'),
        take_profit_percent: Decimal = Decimal('1.9'),
    ):
        self.token = token
        self.account_id = account_id
        self.risk_percentage = risk_percentage
        self.stop_loss_percent = stop_loss_percent / 100
        self.take_profit_percent = take_profit_percent / 100

        # âœ… Ğ—Ğ´ĞµÑÑŒ Ñ…Ñ€Ğ°Ğ½Ğ¸Ğ¼ ÑĞ¾Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²Ğ¸Ğµ order_id â†’ Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ğ°
        self.order_reasons: dict[str, str] = {}

    # ---------------------------
    # Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹
    # ---------------------------
    def _money_value_to_decimal(self, money: MoneyValue) -> Decimal:
        if money is None:
            return Decimal(0)
        return Decimal(money.units) + Decimal(money.nano) / Decimal(1e9)

    async def _get_current_price(self, client: AsyncClient, figi: str) -> Decimal:
        last_prices = await client.market_data.get_last_prices(figi=[figi])
        price = last_prices.last_prices[0].price
        return Decimal(price.units) + Decimal(price.nano) / Decimal(1e9)

    async def _get_current_position(self, client: AsyncClient, figi: str) -> Tuple[Optional[str], int]:
        positions = await client.operations.get_positions(account_id=self.account_id)
        for future in positions.futures:
            if future.figi == figi:
                quantity = getattr(future, 'balance', 0)
                if quantity > 0:
                    return 'long', abs(quantity)
                elif quantity < 0:
                    return 'short', abs(quantity)
        return None, 0

    async def _get_available_funds(self, client: AsyncClient) -> Decimal:
        portfolio = await client.operations.get_portfolio(account_id=self.account_id)
        return self._money_value_to_decimal(portfolio.total_amount_currencies)

    # ---------------------------
    # ĞÑ‚Ğ¼ĞµĞ½Ğ° Ğ¾Ñ€Ğ´ĞµÑ€Ğ¾Ğ²
    # ---------------------------
    async def _cancel_all_limit_orders(self, client: AsyncClient, figi: str):
        orders = await client.orders.get_orders(account_id=self.account_id)
        for order in orders.orders:
            if order.figi == figi and order.order_type == OrderType.ORDER_TYPE_LIMIT:
                await client.orders.cancel_order(account_id=self.account_id, order_id=order.order_id)

    async def _cancel_all_stop_orders(self, client: AsyncClient, figi: str):
        stops = await client.stop_orders.get_stop_orders(account_id=self.account_id)
        for so in stops.stop_orders:
            if so.figi == figi:
                await client.stop_orders.cancel_stop_order(account_id=self.account_id, stop_order_id=so.stop_order_id)

    # ---------------------------
    # Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸
    # ---------------------------
    async def _close_position(self, client: AsyncClient, figi: str, position_type: str, quantity: int):
        await self._cancel_all_stop_orders(client, figi)
        await self._cancel_all_limit_orders(client, figi)

        direction = (
            OrderDirection.ORDER_DIRECTION_SELL if position_type == 'long'
            else OrderDirection.ORDER_DIRECTION_BUY
        )
        order = await self._execute_order(
            client=client,
            figi=figi,
            quantity=quantity,
            direction=direction,
            order_type=OrderType.ORDER_TYPE_MARKET
        )
        # âœ… Ğ—Ğ°Ğ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°ĞµĞ¼ Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ñƒ
        self.order_reasons[order.order_id] = "MARKET"
        return order

    # ---------------------------
    # Ğ’Ñ‹ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ·Ğ°Ñ‰Ğ¸Ñ‚Ğ½Ñ‹Ñ… Ğ¾Ñ€Ğ´ĞµÑ€Ğ¾Ğ²
    # ---------------------------
    async def _place_protection_orders(self, client: AsyncClient, figi: str, direction: str, entry_price: Decimal, quantity: int):
        instrument = (await client.instruments.get_instrument_by(
            id_type=InstrumentIdType.INSTRUMENT_ID_TYPE_FIGI,
            id=figi
        )).instrument
        min_price_increment = self._money_value_to_decimal(instrument.min_price_increment)

        if direction == 'long':
            stop_price = entry_price * (Decimal(1) - self.stop_loss_percent)
            take_profit_price = entry_price * (Decimal(1) + self.take_profit_percent)
            stop_direction = OrderDirection.ORDER_DIRECTION_SELL
        else:
            stop_price = entry_price * (Decimal(1) + self.stop_loss_percent)
            take_profit_price = entry_price * (Decimal(1) - self.take_profit_percent)
            stop_direction = OrderDirection.ORDER_DIRECTION_BUY

        stop_price = (stop_price // min_price_increment) * min_price_increment
        take_profit_price = (take_profit_price // min_price_increment) * min_price_increment

        def decimal_to_money(value: Decimal) -> MoneyValue:
            units = int(value)
            nano = int((value - units) * Decimal('1e9'))
            return MoneyValue(units=units, nano=nano)

        stop_price_money = decimal_to_money(stop_price)
        tp_price_money = decimal_to_money(take_profit_price)

        # Ğ¡Ñ‚Ğ¾Ğ¿-Ğ»Ğ¾ÑÑ
        stop_order = await client.stop_orders.post_stop_order(
            figi=figi,
            quantity=quantity,
            direction=stop_direction,
            account_id=self.account_id,
            stop_price=stop_price_money,
            price=stop_price_money,
            stop_order_type=StopOrderType.STOP_ORDER_TYPE_STOP_LOSS,
            expiration_type=StopOrderExpirationType.STOP_ORDER_EXPIRATION_TYPE_GOOD_TILL_CANCEL
        )
        self.order_reasons[stop_order.stop_order_id] = "STOP_LOSS"

        # Ğ¢ĞµĞ¹Ğº-Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ñ‚ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ğ¾Ğ¼
        tp_order = await client.orders.post_order(
            figi=figi,
            quantity=quantity,
            direction=stop_direction,
            account_id=self.account_id,
            order_type=OrderType.ORDER_TYPE_LIMIT,
            price=tp_price_money
        )
        self.order_reasons[tp_order.order_id] = "TAKE_PROFIT"

    # ---------------------------
    # Ğ˜ÑĞ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ğ¾Ñ€Ğ´ĞµÑ€Ğ¾Ğ²
    # ---------------------------
    async def _execute_order(self, client: AsyncClient, figi: str, quantity: int, direction: OrderDirection, order_type: OrderType):
        return await client.orders.post_order(
            figi=figi,
            quantity=quantity,
            direction=direction,
            account_id=self.account_id,
            order_type=order_type
        )

    async def execute_smart_order(self, figi: str, desired_direction: str, amount: Decimal, close_only: bool = False):
        async with AsyncClient(self.token) as client:
            current_pos_type, current_pos_qty = await self._get_current_position(client, figi)

            if close_only:
                if current_pos_type:
                    await self._close_position(client, figi, current_pos_type, current_pos_qty)
                    return
                raise TradeError("ĞĞµÑ‚ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ´Ğ»Ñ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ñ")

            direction_enum = (
                OrderDirection.ORDER_DIRECTION_BUY if desired_direction == 'long'
                else OrderDirection.ORDER_DIRECTION_SELL
            )

            if current_pos_type and current_pos_type != desired_direction:
                await self._close_position(client, figi, current_pos_type, current_pos_qty)

            futures_margin = await client.instruments.get_futures_margin(figi=figi)
            margin_field = 'initial_margin_on_buy' if desired_direction == 'long' else 'initial_margin_on_sell'
            go_per_lot = self._money_value_to_decimal(getattr(futures_margin, margin_field))
            available_funds = await self._get_available_funds(client)
            quantity = int((available_funds * self.risk_percentage) // go_per_lot)
            if quantity < 1:
                raise TradeError("ĞĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ ÑÑ€ĞµĞ´ÑÑ‚Ğ²")

            order = await self._execute_order(client, figi, quantity, direction_enum, OrderType.ORDER_TYPE_MARKET)
            self.order_reasons[order.order_id] = "MARKET"

            entry_price = await self._get_current_price(client, figi)
            await self._place_protection_orders(client, figi, desired_direction, entry_price, quantity)


========================================

=== app\trading\__init__.py ===



========================================

=== app\trading\test_tinkoff.py ===

# test_tinkoff.py
from trading.tinkoff_client import TinkoffClient
import asyncio

async def main():
    client = TinkoffClient(os.getenv("TINKOFF_TOKEN"), os.getenv("ACCOUNT_ID"))
    
    # Ğ¢ĞµÑÑ‚ Ğ¿Ğ¾Ğ¸ÑĞºĞ° FIGI
    figi = await client.get_figi_by_ticker_async("AAPL")
    print(f"FIGI Ğ´Ğ»Ñ AAPL: {figi}")
    
    # Ğ¢ĞµÑÑ‚ Ğ¾Ñ€Ğ´ĞµÑ€Ğ°
    result = await client.place_market_order_async(figi, 1, "buy")
    print(f"Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚ Ğ¾Ñ€Ğ´ĞµÑ€Ğ°: {result}")

asyncio.run(main())


========================================

=== app\trading\tinkoff_client.py ===

from dataclasses import dataclass
from tinkoff.invest import (
    AsyncClient,
    InstrumentResponse,        
    PortfolioResponse,
    InstrumentIdType,
    MoneyValue
)
from decimal import Decimal
from typing import List, Optional
import logging


logger = logging.getLogger(__name__)

@dataclass
class Position:
    figi: str
    ticker: str
    lots: int
    direction: str

class TinkoffClient:
    def __init__(self, token: str, account_id: str):
        self.token = token
        self.account_id = account_id
        self.RUB_FIGI = "BBG0013HGFT4"

    async def _get_ticker_by_figi(self, figi: str) -> Optional[str]:
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ Ñ‚Ğ¸ĞºĞµÑ€ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ğ° Ğ¿Ğ¾ FIGI"""
        async with AsyncClient(self.token) as client:
            try:
                instrument: InstrumentResponse = await client.instruments.get_instrument_by(
                    id_type=InstrumentIdType.INSTRUMENT_ID_TYPE_FIGI,
                    id=figi
                )
                return instrument.instrument.ticker
            except Exception as e:
                logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ñ‚Ğ¸ĞºĞµÑ€Ğ° Ğ´Ğ»Ñ FIGI {figi}: {str(e)}")
                return None

    async def get_margin_attributes(self):
        async with AsyncClient(self.token) as client:
            return await client.operations.get_margin_attributes(account_id=self.account_id)

    async def get_positions_async(self) -> List[Position]:
        async with AsyncClient(self.token) as client:
            response = await client.operations.get_positions(account_id=self.account_id)
            positions = []
            
            for fut in response.futures:
                # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ°ĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ĞµĞ¹
                lots = abs(fut.balance) if hasattr(fut, 'balance') else abs(fut.quantity)
                direction = 'long' if (fut.balance > 0 if hasattr(fut, 'balance') else fut.quantity > 0) else 'short'
                
                ticker = await self._get_ticker_by_figi(fut.figi)
                if not ticker:
                    ticker = fut.figi  # Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ FIGI ĞµÑĞ»Ğ¸ Ñ‚Ğ¸ĞºĞµÑ€ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½
                    
                positions.append(Position(
                    ticker=ticker,
                    figi=fut.figi,
                    lots=lots,
                    direction=direction
                ))
            
            # Ğ›Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ»Ğ°Ğ´ĞºĞ¸
            logger.debug(f"Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¹: {response}")
            return positions

    async def get_balance_async(self) -> Decimal:
        async with AsyncClient(self.token) as client:
            try:
                # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾ Ğ²Ğ°Ğ»ÑÑ‚Ğ°Ğ¼
                positions = await client.operations.get_positions(account_id=self.account_id)
                logger.debug(f"Raw positions response: {positions}")
                
                rub_balance = Decimal(0)
                
                for money in positions.money:
                    if money.currency == 'rub':
                        rub_balance += self._money_value_to_decimal(money)
                
                # ĞĞ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ†ĞµĞ½Ğ½Ñ‹Ğµ Ğ±ÑƒĞ¼Ğ°Ğ³Ğ¸ Ñ Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ¾Ğ¼ Ğ² RUB
                for security in positions.securities:
                    if security.blocked == 0 and security.balance > 0:
                        instrument = await self._get_instrument_by_figi(security.figi)
                        if instrument and instrument.currency == 'rub':
                            last_price = await self._get_last_price(client, security.figi)
                            rub_balance += last_price * security.balance
                
                logger.info(f"Calculated RUB balance: {rub_balance}")
                return rub_balance
                
            except Exception as e:
                logger.error(f"Balance calculation error: {str(e)}", exc_info=True)
                raise

    async def _get_instrument_by_figi(self, figi: str):
        async with AsyncClient(self.token) as client:
            return await client.instruments.get_instrument_by(
                id_type=InstrumentIdType.INSTRUMENT_ID_TYPE_FIGI,
                id=figi
            )

    async def _get_last_price(self, client: AsyncClient, figi: str) -> Decimal:
        last_price = await client.market_data.get_last_prices(figi=[figi])
        if last_price.last_prices:
            price = last_price.last_prices[0].price
            return Decimal(price.units) + Decimal(price.nano) / Decimal(1e9)
        return Decimal(0)

    def _calculate_available_funds(self, portfolio: PortfolioResponse) -> Decimal:
        cash = next(
            (pos for pos in portfolio.positions 
             if pos.figi == self.RUB_FIGI),
            None
        )
        return self._money_value_to_decimal(cash.current_price) if cash else Decimal(0)

    async def get_figi(self, instrument: str) -> Optional[str]:
        async with AsyncClient(self.token) as client:
            # Ğ£Ğ±Ñ€Ğ°Ğ»Ğ¸ Ğ½ĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¹ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€ instrument_status
            response = await client.instruments.find_instrument(query=instrument)
            return response.instruments[0].figi if response.instruments else None


    @staticmethod
    def _money_value_to_decimal(money: MoneyValue) -> Decimal:
        """ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ°Ñ†Ğ¸Ñ MoneyValue Ğ² Decimal"""
        return Decimal(money.units) + Decimal(money.nano) / Decimal(1e9)


    async def get_balance_async(self) -> Decimal:
        """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾Ğ³Ğ¾ RUB Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ°"""
        async with AsyncClient(self.token) as client:
            try:
                positions = await client.operations.get_positions(account_id=self.account_id)
                rub_balance = Decimal(0)
                
                # ĞĞ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ€ÑƒĞ±Ğ»Ñ‘Ğ²Ñ‹Ğµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸
                for money in positions.money:
                    if money.currency == 'rub':
                        rub_balance += self._money_value_to_decimal(money)
                
                logger.debug(f"Raw RUB balance: {rub_balance}")
                return rub_balance

            except Exception as e:
                logger.error(f"Balance error: {str(e)}", exc_info=True)
                raise

========================================

=== app\trading\init.py ===

from .tinkoff_client import TinkoffClient, Position
from .order_executor import OrderExecutor

__all__ = ['TinkoffClient', 'OrderExecutor', 'Position']


========================================

=== app\trading\models.py ===

from pydantic import BaseModel
from datetime import datetime

class TradeSignal(BaseModel):
    figi: str
    direction: str  # buy/sell
    quantity: int
    timestamp: datetime

class AccountBalance(BaseModel):
    total: float
    available: float
    currency: str
    updated_at: datetime

class InstrumentCache(BaseModel):
    ticker: str
    figi: str
    min_lot: int
    updated_at: datetime    


========================================

=== app\trading\risk_manager.py ===

from decimal import Decimal
from tinkoff.invest import AsyncClient, Quotation, InstrumentShort
from redis import Redis
import logging
from config import Settings

logger = logging.getLogger(__name__)

class RiskManager:
    def __init__(self, token: str, account_id: str):
        self.token = token
        self.account_id = account_id
        self.settings = Settings()
        self.redis = Redis.from_url(self.settings.REDIS_URL)
        self.cache_ttl = 86400  # 24 Ñ‡Ğ°ÑĞ°

    async def get_figi(self, instrument_name: str) -> str:
        """ĞŸĞ¾Ğ¸ÑĞº FIGI Ñ ĞºÑÑˆĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸ĞµĞ¼"""
        cache_key = f"figi:{instrument_name}"
        cached = self.redis.get(cache_key)
        
        if cached:
            return cached.decode()

        async with AsyncClient(self.token) as client:
            try:
                response = await client.instruments.find_instrument(query=instrument_name)
                for instrument in response.instruments:
                    if instrument.ticker.upper() == instrument_name.upper():
                        figi = instrument.figi
                        self.redis.setex(cache_key, self.cache_ttl, figi)
                        return figi
                raise ValueError(f"Ğ˜Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚ {instrument_name} Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½")
            except Exception as e:
                logger.error(f"FIGI search error: {str(e)}")
                raise

    def _validate_min_lot(self, instrument: InstrumentShort, quantity: int):
        """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ»Ğ¾Ñ‚Ğ°"""
        if not hasattr(instrument, 'min_quantity_increment') or instrument.min_quantity_increment is None:
            raise ValueError("Ğ˜Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚ Ğ½Ğµ Ğ¸Ğ¼ĞµĞµÑ‚ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ»Ğ¾Ñ‚Ğ°")

        min_lot = instrument.min_quantity_increment
        if quantity < min_lot:
            raise ValueError(f"ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ {quantity} Ğ¼ĞµĞ½ÑŒÑˆĞµ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ»Ğ¾Ñ‚Ğ° {min_lot}")

    async def validate_order(self, figi: str, quantity: int) -> dict:
        """ĞÑĞ½Ğ¾Ğ²Ğ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿ĞµÑ€ĞµĞ´ Ğ¸ÑĞ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸ĞµĞ¼ Ğ¾Ñ€Ğ´ĞµÑ€Ğ°"""
        try:
            async with AsyncClient(self.token) as client:
                instrument = await client.instruments.get_instrument_by_figi(figi=figi)
                
                # Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ»Ğ¾Ñ‚Ğ°
                self._validate_min_lot(instrument, quantity)

                # ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ñ†ĞµĞ½Ñ‹ Ğ¸ Ñ€Ğ°ÑÑ‡ĞµÑ‚ ÑÑ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸
                last_price = await self._get_last_price(client, figi)
                position_cost = last_price * quantity * instrument.lot

                # ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾Ğ³Ğ¾ Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ°
                portfolio = await client.operations.get_portfolio(account_id=self.account_id)
                total = portfolio.total_amount_portfolio
                available = self._quotation_to_decimal(total)

                # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸
                checks = {
                    'min_lot': quantity >= instrument.min_quantity_increment,
                    'balance': position_cost <= available * Decimal('0.5'),
                    'daily_limit': position_cost <= Decimal('100000'),
                    'instrument_active': instrument.api_trade_available_flag
                }

                return {
                    'status': 'approved' if all(checks.values()) else 'rejected',
                    'checks': checks
                }

        except Exception as e:
            logger.error(f"Risk validation error: {str(e)}")
            return {
                'status': 'error',
                'message': str(e),
                'checks': {}
            }

    async def _get_last_price(self, client: AsyncClient, figi: str) -> Decimal:
        """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ¹ Ñ†ĞµĞ½Ñ‹"""
        order_book = await client.market_data.get_order_book(figi=figi, depth=1)
        return self._quotation_to_decimal(order_book.last_price)

    def _quotation_to_decimal(self, q: Quotation) -> Decimal:
        """ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ°Ñ†Ğ¸Ñ Quotation Ğ² Decimal"""
        return Decimal(q.units) + Decimal(q.nano) / 1e9


========================================

=== app\trading\__pycache__\__init__.cpython-311.pyc ===

ï¿½
    ï¿½4h    ï¿½                   ï¿½   ï¿½ d S )Nï¿½ r   ï¿½    ï¿½/app/trading/__init__.pyï¿½<module>r      s   ï¿½ï¿½ ï¿½ r   

========================================

=== app\trading\__pycache__\tinkoff_client.cpython-311.pyc ===

ï¿½
    ï¿½4h[  ï¿½                   ï¿½|   ï¿½ d dl mZmZmZmZ d dlmZ d dlmZm	Z	 d dl
Z
 e
j        eï¿½  ï¿½        Z G dï¿½ dï¿½  ï¿½        ZdS )ï¿½    )ï¿½AsyncClientï¿½PortfolioResponseï¿½PositionsResponseï¿½
MoneyValue)ï¿½Decimal)ï¿½Listï¿½OptionalNc                   ï¿½r   ï¿½ e Zd Zdedefdï¿½Zdefdï¿½Zdedefdï¿½Zdede	e         fd	ï¿½Z
edefd
ï¿½ï¿½   ï¿½         ZdS )ï¿½TinkoffClientï¿½tokenï¿½
account_idc                 ï¿½0   ï¿½ || _         || _        d| _        d S )Nï¿½BBG0013HGFT4)r   r   ï¿½RUB_FIGI)ï¿½selfr   r   s      ï¿½/app/trading/tinkoff_client.pyï¿½__init__zTinkoffClient.__init__   s   ï¿½ ï¿½ï¿½ï¿½
ï¿½$ï¿½ï¿½ï¿½&ï¿½ï¿½ï¿½ï¿½ï¿½    ï¿½returnc              ï¿½   ï¿½ï¿½   K  ï¿½ t          | j        ï¿½  ï¿½        4 ï¿½d {V ï¿½ï¿½}|j        ï¿½                    | j        ï¿½ï¿½  ï¿½        ï¿½ d {V ï¿½ï¿½}| ï¿½                    |ï¿½  ï¿½        cd d d ï¿½  ï¿½        ï¿½d {V ï¿½ï¿½ S # 1 ï¿½d {V ï¿½ï¿½swxY w Y   d S )N)r   )r   r   ï¿½
operationsï¿½get_portfolior   ï¿½_calculate_available_funds)r   ï¿½clientï¿½responses      r   ï¿½get_balance_asynczTinkoffClient.get_balance_async   s$  ï¿½ ï¿½ ï¿½ ï¿½ï¿½tï¿½zï¿½*ï¿½*ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½fï¿½#ï¿½.ï¿½<ï¿½<ï¿½ï¿½?ï¿½ =ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½Hï¿½ ï¿½2ï¿½2ï¿½8ï¿½<ï¿½<ï¿½		=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ï¿½ï¿½ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=s   ï¿½;A+ï¿½+
A5ï¿½8A5ï¿½	portfolioc                 ï¿½   ï¿½ ï¿½ t          ï¿½ fdï¿½|j        D ï¿½   ï¿½         d ï¿½  ï¿½        }|rï¿½ ï¿½                    |j        ï¿½  ï¿½        nt	          dï¿½  ï¿½        S )Nc              3   ï¿½<   ï¿½K  ï¿½ | ]}|j         ï¿½j        k    ï¿½|V ï¿½ ï¿½d S )N)ï¿½figir   )ï¿½.0ï¿½posr   s     ï¿½r   ï¿½	<genexpr>z;TinkoffClient._calculate_available_funds.<locals>.<genexpr>   s=   ï¿½ï¿½ ï¿½ ï¿½ ï¿½ +ï¿½ +ï¿½Sï¿½ï¿½ï¿½Dï¿½Mï¿½)ï¿½)ï¿½ ï¿½)ï¿½)ï¿½)ï¿½)ï¿½+ï¿½ +r   r   )ï¿½nextï¿½	positionsï¿½_money_value_to_decimalï¿½current_pricer   )r   r   ï¿½cashs   `  r   r   z(TinkoffClient._calculate_available_funds   si   ï¿½ï¿½ ï¿½ï¿½+ï¿½ +ï¿½ +ï¿½ +ï¿½Iï¿½/ï¿½ +ï¿½ +ï¿½ +ï¿½ï¿½
ï¿½ 
ï¿½ï¿½
 DHï¿½Wï¿½tï¿½+ï¿½+ï¿½Dï¿½,>ï¿½?ï¿½?ï¿½?ï¿½Wï¿½UVï¿½Zï¿½Zï¿½Wr   ï¿½
instrumentc              ï¿½   ï¿½ï¿½   K  ï¿½ t          | j        ï¿½  ï¿½        4 ï¿½d {V ï¿½ï¿½}|j        ï¿½                    |ï¿½ï¿½  ï¿½        ï¿½ d {V ï¿½ï¿½}|j        r|j        d         j        nd cd d d ï¿½  ï¿½        ï¿½d {V ï¿½ï¿½ S # 1 ï¿½d {V ï¿½ï¿½swxY w Y   d S )N)ï¿½queryr   )r   r   ï¿½instrumentsï¿½find_instrumentr    )r   r)   r   r   s       r   ï¿½get_figizTinkoffClient.get_figi"   s<  ï¿½ ï¿½ ï¿½ ï¿½ï¿½tï¿½zï¿½*ï¿½*ï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½fï¿½#ï¿½/ï¿½?ï¿½?ï¿½jï¿½?ï¿½Qï¿½Qï¿½Qï¿½Qï¿½Qï¿½Qï¿½Qï¿½Qï¿½Hï¿½3;ï¿½3Gï¿½Qï¿½8ï¿½'ï¿½ï¿½*ï¿½/ï¿½/ï¿½Tï¿½	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ï¿½ï¿½ï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rs   ï¿½<A,ï¿½,
A6ï¿½9A6c                 ï¿½ï¿½   ï¿½ t          | dï¿½  ï¿½        rIt          | dï¿½  ï¿½        r9t          | j        ï¿½  ï¿½        t          | j        ï¿½  ï¿½        t          dï¿½  ï¿½        z  z   S t          dï¿½  ï¿½        S )Nï¿½unitsï¿½nanoi Êš;r   )ï¿½hasattrr   r0   r1   )ï¿½moneys    r   r&   z%TinkoffClient._money_value_to_decimal(   s]   ï¿½ ï¿½ï¿½5ï¿½'ï¿½"ï¿½"ï¿½ 	Oï¿½wï¿½uï¿½fï¿½'=ï¿½'=ï¿½ 	Oï¿½ï¿½5ï¿½;ï¿½'ï¿½'ï¿½'ï¿½%ï¿½*ï¿½*=ï¿½*=ï¿½ï¿½ï¿½ï¿½ï¿½*Nï¿½Nï¿½Nï¿½ï¿½qï¿½zï¿½zï¿½r   N)ï¿½__name__ï¿½
__module__ï¿½__qualname__ï¿½strr   r   r   r   r   r	   r.   ï¿½staticmethodr&   ï¿½ r   r   r   r      sï¿½   ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½'ï¿½cï¿½ 'ï¿½sï¿½ 'ï¿½ 'ï¿½ 'ï¿½ 'ï¿½
=ï¿½ï¿½ =ï¿½ =ï¿½ =ï¿½ =ï¿½Xï¿½4Eï¿½ Xï¿½'ï¿½ Xï¿½ Xï¿½ Xï¿½ Xï¿½Rï¿½ï¿½ Rï¿½ï¿½#ï¿½ï¿½ Rï¿½ Rï¿½ Rï¿½ Rï¿½ ï¿½ï¿½'ï¿½ ï¿½ ï¿½ ï¿½ ï¿½\ï¿½ï¿½ ï¿½ r   r   )ï¿½tinkoff.investr   r   r   r   ï¿½decimalr   ï¿½typingr   r	   ï¿½loggingï¿½	getLoggerr4   ï¿½loggerr   r9   r   r   ï¿½<module>r@      sï¿½   ï¿½ï¿½ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ !ï¿½ !ï¿½ !ï¿½ !ï¿½ !ï¿½ !ï¿½ !ï¿½ !ï¿½ ï¿½ï¿½ï¿½ï¿½	ï¿½ï¿½	ï¿½8ï¿½	$ï¿½	$ï¿½ï¿½ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ r   

========================================

=== app\notifications.py ===

from telegram import Bot
import logging

logger = logging.getLogger(__name__)

class Notifier:
    def __init__(self, token: str, chat_id: int):
        self.bot = Bot(token=token)
        self.chat_id = chat_id

    def send_order_confirmation(self, order_details: dict):
        message = (
            f"ğŸ”„ ĞÑ€Ğ´ĞµÑ€ Ğ¸ÑĞ¿Ğ¾Ğ»Ğ½ĞµĞ½:\\n"
            f"FIGI: {order_details.figi}\\n"
            f"ĞĞ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ: {order_details.direction}\\n"
            f"ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾: {order_details.quantity}\\n"
            f"Ğ¦ĞµĞ½Ğ°: {order_details.executed_price}"
        )
        self.bot.send_message(chat_id=self.chat_id, text=message)


========================================

=== docker-compose.yml ===

version: '3.8'

services:
  bot:
    build: ./app
    command: python -m bot.main
    env_file: .env
    environment:
      - BOT_TOKEN=${BOT_TOKEN}
      - TARGET_USER_ID=${TARGET_USER_ID}
    restart: unless-stopped
    depends_on:
      - redis
      - db

  redis:
    image: redis:alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  db:
    image: postgres:13
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 5s
      timeout: 5s
      retries: 10
    volumes:
      - postgres_data:/var/lib/postgresql/data        

volumes:
  redis_data:
  postgres_data:


========================================

=== .gitignore ===

.env
*.sh
*.info
*.proj
.*
proj.*
backup.*
backup*
save*
*workly
temp
trader*
*.pyc
__pycache__


========================================

=== project-export.txt ===

PROJECT EXPORT

PROJECT STRUCTURE:

ğŸ“ app
  ğŸ“ bot
    ğŸ“ handlers
      ğŸ“„ __init__.py
      ğŸ“„ balance_handler.py
      ğŸ“„ figi_handler.py
      ğŸ“„ init.py
      ğŸ“„ position_handler.py
      ğŸ“„ trade_handlers.py
    ğŸ“„ __init__.py
    ğŸ“„ main.py
  ğŸ“ scripts
    ğŸ“ __pycache__
      ğŸ“„ tinkoff_check.cpython-311.pyc
    ğŸ“„ tinkoff_check.py
  ğŸ“ trading
    ğŸ“ __pycache__
      ğŸ“„ __init__.cpython-311.pyc
      ğŸ“„ tinkoff_client.cpython-311.pyc
    ğŸ“„ __init__.py
    ğŸ“„ init.py
    ğŸ“„ models.py
    ğŸ“„ order_executor.py
    ğŸ“„ order_watcher.py
    ğŸ“„ risk_manager.py
    ğŸ“„ test_tinkoff.py
    ğŸ“„ tinkoff_client.py
  ğŸ“„ __init__.py
  ğŸ“„ config.py
  ğŸ“„ Dockerfile
  ğŸ“„ Dockerfile.last
  ğŸ“„ notifications.py
  ğŸ“„ redis_queue.py
  ğŸ“„ requirements.txt
ğŸ“ db
  ğŸ“„ init.sql
ğŸ“„ .env
ğŸ“„ .gitignore
ğŸ“„ docker-compose.yml

FILES:

=== .env ===

BOT_TOKEN=7627503533:AAHJuYt3Bh7k-Y0SyOEeujPJ_4wjMj8c555
TARGET_USER_ID=1822765755
TINKOFF_TOKEN=t.cEGrGB9IbFCVpLzEO94lOx0_n0av3Nwq0pAWhVmpMIR27-bI8pPjomMZiOSuRzScDUyt7XwTMKkFvhfuMpQ555
ACCOUNT_ID=2213960479
REDIS_URL=redis://redis:6379/0
POSTGRES_DB=trading_data  # Ğ”Ğ¾Ğ»Ğ¶Ğ½Ğ¾ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´Ğ°Ñ‚ÑŒ Ñ Ğ¸Ğ¼ĞµĞ½ĞµĞ¼ Ğ¸Ğ· docker-compose
POSTGRES_USER=bot
POSTGRES_PASSWORD=11111111
DB_URL=postgresql://bot:11111111@db:5432/trading_data


========================================

=== app\config.py ===

# config.py
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    BOT_TOKEN = os.getenv("BOT_TOKEN")
    TINKOFF_TOKEN = os.getenv("TINKOFF_TOKEN")
    ACCOUNT_ID = os.getenv("ACCOUNT_ID")
    LOG_LEVEL = os.getenv("LOG_LEVEL", "DEBUG")    


========================================

=== app\scripts\tinkoff_check.py ===

import os
import asyncio
from tinkoff.invest import AsyncClient, InstrumentIdType
from trading.tinkoff_client import TinkoffClient

async def main():
    token = os.getenv("TINKOFF_TOKEN")
    account_id = os.getenv("ACCOUNT_ID")
    
    client = TinkoffClient(token, account_id)
    
    # Ğ¢ĞµÑÑ‚ Ğ¿Ğ¾Ğ¸ÑĞºĞ° FIGI
    figi = await client.get_figi_by_ticker("SBER")
    print(f"FIGI Ğ´Ğ»Ñ SBER: {figi}")
    
    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ğ°
    async with AsyncClient(token) as api_client:
        instrument = await api_client.instruments.get_instrument_by(
            id_type=InstrumentIdType.INSTRUMENT_ID_TYPE_FIGI,
            id=figi
        )
        print(f"Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ± Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ğµ: {instrument}")

if __name__ == "__main__":
    asyncio.run(main())

========================================

=== app\scripts\__pycache__\tinkoff_check.cpython-311.pyc ===

ï¿½
    ï¿½0h"  ï¿½                   ï¿½x   ï¿½ d dl Z d dlZd dlmZmZ d dlmZ dï¿½ Zedk    r ej	         eï¿½   ï¿½         ï¿½  ï¿½         dS dS )ï¿½    N)ï¿½AsyncClientï¿½InstrumentIdType)ï¿½TinkoffClientc               ï¿½   ï¿½ï¿½  K  ï¿½ t          j        dï¿½  ï¿½        } t          j        dï¿½  ï¿½        }t          | |ï¿½  ï¿½        }|ï¿½                    dï¿½  ï¿½        ï¿½ d {V ï¿½ï¿½}t	          d|ï¿½ ï¿½ï¿½  ï¿½         t          | ï¿½  ï¿½        4 ï¿½d {V ï¿½ï¿½}|j        ï¿½                    t          j	        |ï¿½ï¿½  ï¿½        ï¿½ d {V ï¿½ï¿½}t	          d|ï¿½ ï¿½ï¿½  ï¿½         d d d ï¿½  ï¿½        ï¿½d {V ï¿½ï¿½ d S # 1 ï¿½d {V ï¿½ï¿½swxY w Y   d S )Nï¿½TINKOFF_TOKENï¿½
ACCOUNT_IDï¿½SBERu   FIGI Ğ´Ğ»Ñ SBER: )ï¿½id_typeï¿½idu2   Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ± Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ğµ: )
ï¿½osï¿½getenvr   ï¿½get_figi_by_tickerï¿½printr   ï¿½instrumentsï¿½get_instrument_byr   ï¿½INSTRUMENT_ID_TYPE_FIGI)ï¿½tokenï¿½
account_idï¿½clientï¿½figiï¿½
api_clientï¿½
instruments         ï¿½/app/scripts/tinkoff_check.pyï¿½mainr      sï¿½  ï¿½ ï¿½ ï¿½ ï¿½ï¿½Iï¿½oï¿½&ï¿½&ï¿½Eï¿½ï¿½ï¿½<ï¿½(ï¿½(ï¿½Jï¿½ï¿½5ï¿½*ï¿½-ï¿½-ï¿½Fï¿½ ï¿½*ï¿½*ï¿½6ï¿½2ï¿½2ï¿½2ï¿½2ï¿½2ï¿½2ï¿½2ï¿½2ï¿½Dï¿½	ï¿½
%ï¿½tï¿½
%ï¿½
%ï¿½&ï¿½&ï¿½&ï¿½ ï¿½5ï¿½!ï¿½!ï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½Zï¿½%ï¿½1ï¿½Cï¿½Cï¿½$ï¿½<ï¿½ï¿½ Dï¿½ 
ï¿½ 
ï¿½ 
ï¿½ 
ï¿½ 
ï¿½ 
ï¿½ 
ï¿½ 
ï¿½
ï¿½ 	ï¿½Oï¿½:ï¿½Oï¿½Oï¿½Pï¿½Pï¿½Pï¿½Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ï¿½ï¿½ï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qï¿½ Qs   ï¿½=?Cï¿½
Cï¿½Cï¿½__main__)
r   ï¿½asyncioï¿½tinkoff.investr   r   ï¿½trading.tinkoff_clientr   r   ï¿½__name__ï¿½runï¿½ ï¿½    r   ï¿½<module>r#      sï¿½   ï¿½ï¿½ 	ï¿½	ï¿½	ï¿½	ï¿½ ï¿½ï¿½ï¿½ï¿½ 8ï¿½ 8ï¿½ 8ï¿½ 8ï¿½ 8ï¿½ 8ï¿½ 8ï¿½ 8ï¿½ 0ï¿½ 0ï¿½ 0ï¿½ 0ï¿½ 0ï¿½ 0ï¿½Qï¿½ Qï¿½ Qï¿½$ ï¿½zï¿½ï¿½ï¿½ï¿½Gï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½r"   

========================================

=== app\bot\handlers\figi_handler.py ===

from telegram import Update, Message
from telegram.ext import ContextTypes
from telegram.helpers import escape_markdown
from tinkoff.invest import AsyncClient, InstrumentShort
import os
import logging

logger = logging.getLogger(__name__)

async def handle_figi_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        message = update.message or update.channel_post
        if not message or not message.text:
            return

        # Ğ˜Ğ·Ğ²Ğ»ĞµĞºĞ°ĞµĞ¼ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ğ° Ğ¿Ğ¾ÑĞ»Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹ figi
        parts = message.text.split(maxsplit=1)
        if len(parts) < 2:
            await message.reply_text("âŒ Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ğ°")
            return

        instrument_name = parts[1].strip()
        await process_figi_request(message, instrument_name)

    except Exception as e:
        logger.error(f"Error: {str(e)}", exc_info=True)
        await message.reply_text("âš ï¸ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ°")

async def process_figi_request(message: Message, instrument_name: str):
    try:
        token = os.getenv("TINKOFF_TOKEN")
        if not token:
            logger.error("TINKOFF_TOKEN not configured!")
            await message.reply_text("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ğ¸")
            return

        async with AsyncClient(token) as client:
            # Ğ˜Ñ‰ĞµĞ¼ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚
            response = await client.instruments.find_instrument(query=instrument_name)
            
            if not response.instruments:
                await message.reply_text(f"âŒ Ğ˜Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚ '{escape_markdown(instrument_name, version=2)}' Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½")
                return

            # Ğ‘ĞµÑ€ĞµĞ¼ Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¹ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚ Ğ¸ ÑĞºÑ€Ğ°Ğ½Ğ¸Ñ€ÑƒĞµĞ¼ Ğ²ÑĞµ Ğ¿Ğ¾Ğ»Ñ
            instrument = response.instruments[0]
            safe_data = {
                'name': escape_markdown(instrument.name, version=2),
                'figi': escape_markdown(instrument.figi, version=2),
                'ticker': escape_markdown(instrument.ticker, version=2)
            }

            response_text = (
                f"ğŸ” *{safe_data['name']}*\n"
                f"FIGI: \`{safe_data['figi']}\`\n"
                f"Ğ¢Ğ¸ĞºĞµÑ€: {safe_data['ticker']}"
            )
            
            await message.reply_text(response_text, parse_mode='MarkdownV2')

    except Exception as e:
        logger.error(f"API Error: {str(e)}", exc_info=True)
        await message.reply_text("âš ï¸ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ Ğº Ğ±Ñ€Ğ¾ĞºĞµÑ€Ñƒ")


========================================

=== app\bot\handlers\__init__.py ===

from .trade_handlers import handle_buy, handle_sell
from .balance_handler import handle_balance
from .figi_handler import handle_figi_message
from .position_handler import handle_positions



========================================

=== app\bot\handlers\balance_handler.py ===

from telegram import Update
from telegram.ext import ContextTypes
from trading.tinkoff_client import TinkoffClient
import os
import logging
import asyncio  

logger = logging.getLogger(__name__)

async def handle_balance(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        message = update.message or update.channel_post
        client = TinkoffClient(os.getenv("TINKOFF_TOKEN"), os.getenv("ACCOUNT_ID"))
        
        balance = await client.get_balance_async()
        logger.debug(f"Raw balance data: {balance}")
        
        await message.reply_text(f"ğŸ’° Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ: {balance:.2f} RUB")
    except Exception as e:
        logger.error(f"Balance error: {str(e)}", exc_info=True)
        await message.reply_text("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ°")


========================================

=== app\bot\handlers\trade_handlers.py ===

# app/bot/handlers/trade_handlers.py
from telegram import Update
from telegram.ext import ContextTypes
import os
import logging
import asyncio
from decimal import Decimal
from trading.tinkoff_client import TinkoffClient, Position 
from trading.order_executor import OrderExecutor

logger = logging.getLogger(__name__)

class TradeError(Exception):
    pass

async def _process_trade_command(update: Update, context: ContextTypes.DEFAULT_TYPE, action: str):
    try:
        message = update.message or update.channel_post
        if not message or not message.text:
            return

        instrument = message.text.split()[1].upper()
        logger.info(f"Processing {action.upper()} command for {instrument}")

        tinkoff_token = os.getenv("TINKOFF_TOKEN")
        account_id = os.getenv("ACCOUNT_ID")
        
        client = TinkoffClient(tinkoff_token, account_id)
        executor = OrderExecutor(tinkoff_token, account_id)

        figi = await client.get_figi(instrument)
        if not figi:
            raise TradeError(f"Ğ˜Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚ {instrument} Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½")

        positions = await client.get_positions_async()
        
        # ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° buy/sell Ñ‡ĞµÑ€ĞµĞ· ĞµĞ´Ğ¸Ğ½Ñ‹Ğ¹ Ğ¼ĞµÑ‚Ğ¾Ğ´ execute_smart_order
        if action == 'buy':
            await _handle_trade_logic(
                client=client,
                executor=executor,
                figi=figi,
                instrument=instrument,
                positions=positions,
                direction='long',
                risk_percent=Decimal('0.4')  # 40% Ğ¾Ñ‚ Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ° Ğ´Ğ»Ñ Ğ»Ğ¾Ğ½Ğ³Ğ°
            )
        elif action == 'sell':
            await _handle_trade_logic(
                client=client,
                executor=executor,
                figi=figi,
                instrument=instrument,
                positions=positions,
                direction='short',
                risk_percent=Decimal('0.3')  # 30% Ğ¾Ñ‚ Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ° Ğ´Ğ»Ñ ÑˆĞ¾Ñ€Ñ‚Ğ°
            )

        await message.reply_text(f"âœ… ĞĞ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ {action.upper()} Ğ´Ğ»Ñ {instrument} Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ°")

    except TradeError as e:
        await message.reply_text(f"âš ï¸ {str(e)}")
    except Exception as e:
        logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)}", exc_info=True)
        await message.reply_text("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸")

async def _handle_trade_logic(
    client: TinkoffClient,
    executor: OrderExecutor,
    figi: str,
    instrument: str,
    positions: list[Position],
    direction: str,
    risk_percent: Decimal
):
    """ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ğ°Ñ Ğ»Ğ¾Ğ³Ğ¸ĞºĞ° Ñ ÑƒÑ‡ĞµÑ‚Ğ¾Ğ¼ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¹ Ğ² API"""
    try:
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶Ğ½ÑƒÑ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ
        opposite_pos = next(
            (p for p in positions 
             if p.ticker == instrument 
             and p.direction != direction),
            None
        )
        
        # Ğ—Ğ°ĞºÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶Ğ½ÑƒÑ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ ĞµÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ
        if opposite_pos:
            logger.info(f"Closing {opposite_pos.direction} position: {opposite_pos.lots} lots")
            await executor.execute_smart_order(
                figi=figi,
                desired_direction=opposite_pos.direction,
                amount=Decimal(opposite_pos.lots),
                close_only=True
            )
            await asyncio.sleep(1)

        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ
        balance = await client.get_balance_async()
        if balance <= 0:
            raise TradeError("ĞĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ ÑÑ€ĞµĞ´ÑÑ‚Ğ²")

        # Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞµĞ¼ Ğ¾ÑĞ½Ğ¾Ğ²Ğ½ÑƒÑ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ
        await executor.execute_smart_order(
            figi=figi,
            desired_direction=direction,
            amount=balance * risk_percent
        )

    except Exception as e:
        logger.error(f"Trade error ({direction}): {str(e)}", exc_info=True)
        raise TradeError(f"ĞÑˆĞ¸Ğ±ĞºĞ° {direction} Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸: {str(e)}")

async def handle_buy(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await _process_trade_command(update, context, 'buy')

async def handle_sell(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await _process_trade_command(update, context, 'sell')

========================================

=== app\bot\handlers\init.py ===

from .balance_handler import handle_balance
from .figi_handler import handle_figi_message
from .trade_handlers import handle_buy, handle_sell
from .position_handler import handle_positions


========================================

=== app\bot\handlers\position_handler.py ===

from telegram import Update
from telegram.ext import ContextTypes
from trading.tinkoff_client import TinkoffClient
import os
import logging

logger = logging.getLogger(__name__)

async def handle_positions(update: Update, context: ContextTypes.DEFAULT_TYPE):
    message = update.message or update.channel_post  # Ğ˜ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸ NoneType
    if not message:
        return

    try:
        client = TinkoffClient(os.getenv("TINKOFF_TOKEN"), os.getenv("ACCOUNT_ID"))
        positions = await client.get_positions_async()

        if not positions:
            await message.reply_text("ğŸ” ĞĞµÑ‚ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¹")
            return

        response = "ğŸ“Š ĞÑ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸:\n\n"
        for pos in positions:
            response += f"â€¢ {pos.ticker}: {pos.lots} Ğ»Ğ¾Ñ‚Ğ¾Ğ² ({pos.direction.upper()})\n"

        await message.reply_text(response)

    except Exception as e:
        logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)}", exc_info=True)
        await message.reply_text("âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğ¸ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¹")


========================================

=== app\bot\__init__.py ===

# Ğ£Ğ¿Ñ€Ğ¾Ñ‰Ğ°ĞµĞ¼ Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚
from .handlers import (
    handle_balance,
    handle_figi_message,
    handle_buy,
    handle_sell,
    handle_positions
)


========================================

=== app\bot\main.py ===

from telegram import Update
from telegram.ext import (
    ApplicationBuilder,
    ContextTypes,
    MessageHandler,
    CommandHandler,
    filters
)
from bot.handlers import (
    handle_balance,
    handle_figi_message,
    handle_buy,
    handle_sell,
    handle_positions
)
import os
import logging
import re
import asyncio

# Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¾Ğ½Ğ°Ğ»
from trading.order_executor import OrderExecutor
from trading.order_watcher import OrderWatcher  # <-- Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ¼Ğ¾Ğ´ÑƒĞ»ÑŒ

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ°: {context.error}", exc_info=True)
    try:
        message = update.message or update.channel_post
        if message:
            await message.reply_text("âš ï¸ ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ²Ğ½ÑƒÑ‚Ñ€ĞµĞ½Ğ½ÑÑ Ğ¾ÑˆĞ¸Ğ±ĞºĞ°")
    except Exception as e:
        logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ² error_handler: {str(e)}")

def setup_handlers(application):
    # Balance handler
    application.add_handler(MessageHandler(
        filters.TEXT & filters.Regex(re.compile(r'^(Ğ±Ğ°Ğ»Ğ°Ğ½Ñ|balance)$', re.IGNORECASE)),
        handle_balance
    ))
    
    # FIGI info handler
    application.add_handler(MessageHandler(
        filters.TEXT & filters.Regex(re.compile(r'^figi\s+\w+', re.IGNORECASE)),
        handle_figi_message
    ))
    
    # Positions handler
    application.add_handler(MessageHandler(
        filters.TEXT & filters.Regex(re.compile(r'^(ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ|positions)$', re.IGNORECASE)),
        handle_positions
    ))
    
    # Buy/Sell handlers
    application.add_handler(MessageHandler(
        filters.TEXT & filters.Regex(re.compile(r'^buy\s+\w+', re.IGNORECASE)),
        handle_buy
    ))
    
    application.add_handler(MessageHandler(
        filters.TEXT & filters.Regex(re.compile(r'^sell\s+\w+', re.IGNORECASE)),
        handle_sell
    ))

def main():
    token = os.getenv("BOT_TOKEN")
    tinkoff_token = os.getenv("TINKOFF_TOKEN")
    account_id = os.getenv("ACCOUNT_ID")
    chat_id = os.getenv("TG_CHAT_ID")  # ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€ (Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ·Ğ°Ğ´Ğ°Ñ‚ÑŒ Ğ² .env)

    if not token:
        raise ValueError("ĞĞµ Ğ·Ğ°Ğ´Ğ°Ğ½ BOT_TOKEN")
    if not tinkoff_token or not account_id:
        raise ValueError("ĞĞµ Ğ·Ğ°Ğ´Ğ°Ğ½Ñ‹ TINKOFF_TOKEN Ğ¸Ğ»Ğ¸ ACCOUNT_ID")

    # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Telegram-Ğ±Ğ¾Ñ‚
    application = ApplicationBuilder().token(token).build()
    setup_handlers(application)
    application.add_error_handler(error_handler)

    # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ğ¸ÑĞ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»Ñ Ğ¸ Ğ²Ğ¾Ñ‚Ñ‡ĞµÑ€Ğ°
    executor = OrderExecutor(tinkoff_token, account_id)
    watcher = OrderWatcher(
        tinkoff_token,
        account_id,
        executor,
        tg_bot=application.bot,
        chat_id=chat_id
    )

    # Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ğ²Ğ¾Ñ‚Ñ‡ĞµÑ€ Ğ² Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ğ¾Ğ¹ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğµ
    loop = asyncio.get_event_loop()
    loop.create_task(watcher.watch_trades())

    logger.info("Ğ‘Ğ¾Ñ‚ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½")
    application.run_polling()

if __name__ == '__main__':
    main()


========================================

=== app\Dockerfile.last ===

FROM python:3.10-slim

WORKDIR /app

# ĞšÑÑˆĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt \\
    && pip install aiohttp

# ĞÑ‚Ğ´ĞµĞ»ÑŒĞ½Ğ¾ ĞºĞ¾Ğ¿Ğ¸Ñ€ÑƒĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ½ÑƒĞ¶Ğ½Ñ‹Ğµ Ñ„Ğ°Ğ¹Ğ»Ñ‹
COPY config.py .
COPY trading/ ./trading/

# Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºÑƒ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ¾ÑĞ¿Ğ¾ÑĞ¾Ğ±Ğ½Ğ¾ÑÑ‚Ğ¸
RUN python -c "from trading.order_executor import OrderExecutor; print('Module imports OK')" \\
    || (echo "Import error!" && exit 1)

CMD ["python", "-m", "trading.order_executor", "app.bot.main"]


========================================

=== app\Dockerfile ===

FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
RUN pip install --upgrade tinkoff-investments
RUN pip install uuid
RUN pip install --upgrade protobuf

# ĞšĞ¾Ğ¿Ğ¸Ñ€ÑƒĞµĞ¼ Ğ²ÑÑ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñƒ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°
COPY . .

# Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½ÑƒÑ Ğ¾ĞºÑ€ÑƒĞ¶ĞµĞ½Ğ¸Ñ Ğ´Ğ»Ñ Python
ENV PYTHONPATH="\${PYTHONPATH}:/app"
ENV PYTHONPATH "\${PYTHONPATH}:/app:/app/trading:/app/bot"

CMD ["python", "-m", "bot.main"]


========================================

=== app\redis_queue.py ===

import redis
from pydantic import BaseModel
import json
from config import Settings

settings = Settings()

class RedisQueue:
    def __init__(self):
        self.redis = redis.Redis.from_url(settings.REDIS_URL)
        self.channel = 'trading_signals'

    async def publish_signal(self, signal: dict):
        self.redis.publish(self.channel, json.dumps(signal))

    async def listen_signals(self, callback):
        pubsub = self.redis.pubsub()
        pubsub.subscribe(self.channel)
        for message in pubsub.listen():
            if message['type'] == 'message':
                callback(json.loads(message['data']))

class TradeSignal(BaseModel):
    action: str  # buy/sell/balance
    figi: str = "NG_FIGI"  # Ğ—Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚Ğµ Ğ½Ğ° Ñ€ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ FIGI
    quantity: int = 1
    user_id: int
    chat_id: int


========================================

=== app\__init__.py ===



========================================

=== app\requirements.txt ===

python-telegram-bot>=20.0
# tinkoff-investments  # ĞĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ğ°Ñ Ğ²ĞµÑ€ÑĞ¸Ñ API
# tinkoff-investments>=0.2.0b1 
tinkoff-investments
pydantic-settings>=2.0
redis>=4.5.4
asyncpg>=0.28.0
apscheduler>=3.10.0
aiohttp>=3.8.0
async-timeout>=4.0.2
backoff==2.2.1
pydantic>=2.0
numpy>=1.22.0  # Ğ”Ğ»Ñ RiskManager


========================================

=== app\trading\order_watcher.py ===

import logging
from tinkoff.invest import AsyncClient
from tinkoff.invest.async_services import AsyncServices
from .order_executor import OrderExecutor

logger = logging.getLogger(__name__)


class OrderWatcher:
    def __init__(self, token: str, account_id: str, executor: OrderExecutor, tg_bot=None, chat_id=None):
        self.token = token
        self.account_id = account_id
        self.executor = executor
        self.tg_bot = tg_bot
        self.chat_id = chat_id

    async def watch_trades(self):
        async with AsyncClient(self.token) as client:
            stream: AsyncServices.TradesStream = client.trades_stream
            logger.info("OrderWatcher Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½: ÑĞ»ÑƒÑˆĞ°ĞµĞ¼ Ğ¿Ğ¾Ñ‚Ğ¾Ğº ÑĞ´ĞµĞ»Ğ¾Ğº...")

            async for event in stream.trades_stream(accounts=[self.account_id]):
                try:
                    if not event.order_trades:
                        continue

                    figi = event.order_trades.figi
                    order_id = event.order_trades.order_id

                    # âœ… ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼ Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ñƒ Ğ¿Ğ¾ ÑĞ»Ğ¾Ğ²Ğ°Ñ€Ñ executor'Ğ°
                    reason = self.executor.order_reasons.get(order_id, "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")

                    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ¿Ğ¾ÑĞ»Ğµ ÑĞ´ĞµĞ»ĞºĞ¸
                    pos_type, qty = await self.executor._get_current_position(client, figi)
                    if not pos_type or qty == 0:
                        await self.executor._cancel_all_stop_orders(client, figi)
                        await self.executor._cancel_all_limit_orders(client, figi)

                        msg = f"â„¹ï¸ ĞŸĞ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ¿Ğ¾ {figi} Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ° ({reason}). Ğ’ÑĞµ ÑÑ‚Ğ¾Ğ¿Ñ‹ Ğ¸ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ñ‹ ÑĞ½ÑÑ‚Ñ‹."
                        logger.info(msg)

                        if self.tg_bot and self.chat_id:
                            try:
                                await self.tg_bot.send_message(chat_id=self.chat_id, text=msg)
                            except Exception as e:
                                logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞµ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ: {e}")

                except Exception as e:
                    logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ Ğ² OrderWatcher: {e}", exc_info=True)


========================================

=== app\trading\order_executor.py ===

from tinkoff.invest import (
    AsyncClient,
    OrderDirection,
    OrderType,
    InstrumentIdType,
    MoneyValue,
    StopOrderType,
    StopOrderExpirationType
)
from decimal import Decimal
import logging
import asyncio
from typing import Optional, Tuple
from dataclasses import dataclass

logger = logging.getLogger(__name__)

@dataclass
class TradeError(Exception):
    message: str


class OrderExecutor:
    def __init__(
        self,
        token: str,
        account_id: str,
        risk_percentage: Decimal = Decimal('0.4'),
        stop_loss_percent: Decimal = Decimal('0.51'),
        take_profit_percent: Decimal = Decimal('1.9'),
    ):
        self.token = token
        self.account_id = account_id
        self.risk_percentage = risk_percentage
        self.stop_loss_percent = stop_loss_percent / 100
        self.take_profit_percent = take_profit_percent / 100

        # âœ… Ğ—Ğ´ĞµÑÑŒ Ñ…Ñ€Ğ°Ğ½Ğ¸Ğ¼ ÑĞ¾Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²Ğ¸Ğµ order_id â†’ Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ğ°
        self.order_reasons: dict[str, str] = {}

    # ---------------------------
    # Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹
    # ---------------------------
    def _money_value_to_decimal(self, money: MoneyValue) -> Decimal:
        if money is None:
            return Decimal(0)
        return Decimal(money.units) + Decimal(money.nano) / Decimal(1e9)

    async def _get_current_price(self, client: AsyncClient, figi: str) -> Decimal:
        last_prices = await client.market_data.get_last_prices(figi=[figi])
        price = last_prices.last_prices[0].price
        return Decimal(price.units) + Decimal(price.nano) / Decimal(1e9)

    async def _get_current_position(self, client: AsyncClient, figi: str) -> Tuple[Optional[str], int]:
        positions = await client.operations.get_positions(account_id=self.account_id)
        for future in positions.futures:
            if future.figi == figi:
                quantity = getattr(future, 'balance', 0)
                if quantity > 0:
                    return 'long', abs(quantity)
                elif quantity < 0:
                    return 'short', abs(quantity)
        return None, 0

    async def _get_available_funds(self, client: AsyncClient) -> Decimal:
        portfolio = await client.operations.get_portfolio(account_id=self.account_id)
        return self._money_value_to_decimal(portfolio.total_amount_currencies)

    # ---------------------------
    # ĞÑ‚Ğ¼ĞµĞ½Ğ° Ğ¾Ñ€Ğ´ĞµÑ€Ğ¾Ğ²
    # ---------------------------
    async def _cancel_all_limit_orders(self, client: AsyncClient, figi: str):
        orders = await client.orders.get_orders(account_id=self.account_id)
        for order in orders.orders:
            if order.figi == figi and order.order_type == OrderType.ORDER_TYPE_LIMIT:
                await client.orders.cancel_order(account_id=self.account_id, order_id=order.order_id)

    async def _cancel_all_stop_orders(self, client: AsyncClient, figi: str):
        stops = await client.stop_orders.get_stop_orders(account_id=self.account_id)
        for so in stops.stop_orders:
            if so.figi == figi:
                await client.stop_orders.cancel_stop_order(account_id=self.account_id, stop_order_id=so.stop_order_id)

    # ---------------------------
    # Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸
    # ---------------------------
    async def _close_position(self, client: AsyncClient, figi: str, position_type: str, quantity: int):
        await self._cancel_all_stop_orders(client, figi)
        await self._cancel_all_limit_orders(client, figi)

        direction = (
            OrderDirection.ORDER_DIRECTION_SELL if position_type == 'long'
            else OrderDirection.ORDER_DIRECTION_BUY
        )
        order = await self._execute_order(
            client=client,
            figi=figi,
            quantity=quantity,
            direction=direction,
            order_type=OrderType.ORDER_TYPE_MARKET
        )
        # âœ… Ğ—Ğ°Ğ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°ĞµĞ¼ Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ñƒ
        self.order_reasons[order.order_id] = "MARKET"
        return order

    # ---------------------------
    # Ğ’Ñ‹ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ·Ğ°Ñ‰Ğ¸Ñ‚Ğ½Ñ‹Ñ… Ğ¾Ñ€Ğ´ĞµÑ€Ğ¾Ğ²
    # ---------------------------
    async def _place_protection_orders(self, client: AsyncClient, figi: str, direction: str, entry_price: Decimal, quantity: int):
        instrument = (await client.instruments.get_instrument_by(
            id_type=InstrumentIdType.INSTRUMENT_ID_TYPE_FIGI,
            id=figi
        )).instrument
        min_price_increment = self._money_value_to_decimal(instrument.min_price_increment)

        if direction == 'long':
            stop_price = entry_price * (Decimal(1) - self.stop_loss_percent)
            take_profit_price = entry_price * (Decimal(1) + self.take_profit_percent)
            stop_direction = OrderDirection.ORDER_DIRECTION_SELL
        else:
            stop_price = entry_price * (Decimal(1) + self.stop_loss_percent)
            take_profit_price = entry_price * (Decimal(1) - self.take_profit_percent)
            stop_direction = OrderDirection.ORDER_DIRECTION_BUY

        stop_price = (stop_price // min_price_increment) * min_price_increment
        take_profit_price = (take_profit_price // min_price_increment) * min_price_increment

        def decimal_to_money(value: Decimal) -> MoneyValue:
            units = int(value)
            nano = int((value - units) * Decimal('1e9'))
            return MoneyValue(units=units, nano=nano)

        stop_price_money = decimal_to_money(stop_price)
        tp_price_money = decimal_to_money(take_profit_price)

        # Ğ¡Ñ‚Ğ¾Ğ¿-Ğ»Ğ¾ÑÑ
        stop_order = await client.stop_orders.post_stop_order(
            figi=figi,
            quantity=quantity,
            direction=stop_direction,
            account_id=self.account_id,
            stop_price=stop_price_money,
            price=stop_price_money,
            stop_order_type=StopOrderType.STOP_ORDER_TYPE_STOP_LOSS,
            expiration_type=StopOrderExpirationType.STOP_ORDER_EXPIRATION_TYPE_GOOD_TILL_CANCEL
        )
        self.order_reasons[stop_order.stop_order_id] = "STOP_LOSS"

        # Ğ¢ĞµĞ¹Ğº-Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ñ‚ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ğ¾Ğ¼
        tp_order = await client.orders.post_order(
            figi=figi,
            quantity=quantity,
            direction=stop_direction,
            account_id=self.account_id,
            order_type=OrderType.ORDER_TYPE_LIMIT,
            price=tp_price_money
        )
        self.order_reasons[tp_order.order_id] = "TAKE_PROFIT"

    # ---------------------------
    # Ğ˜ÑĞ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ğ¾Ñ€Ğ´ĞµÑ€Ğ¾Ğ²
    # ---------------------------
    async def _execute_order(self, client: AsyncClient, figi: str, quantity: int, direction: OrderDirection, order_type: OrderType):
        return await client.orders.post_order(
            figi=figi,
            quantity=quantity,
            direction=direction,
            account_id=self.account_id,
            order_type=order_type
        )

    async def execute_smart_order(self, figi: str, desired_direction: str, amount: Decimal, close_only: bool = False):
        async with AsyncClient(self.token) as client:
            current_pos_type, current_pos_qty = await self._get_current_position(client, figi)

            if close_only:
                if current_pos_type:
                    await self._close_position(client, figi, current_pos_type, current_pos_qty)
                    return
                raise TradeError("ĞĞµÑ‚ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ´Ğ»Ñ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ñ")

            direction_enum = (
                OrderDirection.ORDER_DIRECTION_BUY if desired_direction == 'long'
                else OrderDirection.ORDER_DIRECTION_SELL
            )

            if current_pos_type and current_pos_type != desired_direction:
                await self._close_position(client, figi, current_pos_type, current_pos_qty)

            futures_margin = await client.instruments.get_futures_margin(figi=figi)
            margin_field = 'initial_margin_on_buy' if desired_direction == 'long' else 'initial_margin_on_sell'
            go_per_lot = self._money_value_to_decimal(getattr(futures_margin, margin_field))
            available_funds = await self._get_available_funds(client)
            quantity = int((available_funds * self.risk_percentage) // go_per_lot)
            if quantity < 1:
                raise TradeError("ĞĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ ÑÑ€ĞµĞ´ÑÑ‚Ğ²")

            order = await self._execute_order(client, figi, quantity, direction_enum, OrderType.ORDER_TYPE_MARKET)
            self.order_reasons[order.order_id] = "MARKET"

            entry_price = await self._get_current_price(client, figi)
            await self._place_protection_orders(client, figi, desired_direction, entry_price, quantity)


========================================

=== app\trading\__init__.py ===



========================================

=== app\trading\test_tinkoff.py ===

# test_tinkoff.py
from trading.tinkoff_client import TinkoffClient
import asyncio

async def main():
    client = TinkoffClient(os.getenv("TINKOFF_TOKEN"), os.getenv("ACCOUNT_ID"))
    
    # Ğ¢ĞµÑÑ‚ Ğ¿Ğ¾Ğ¸ÑĞºĞ° FIGI
    figi = await client.get_figi_by_ticker_async("AAPL")
    print(f"FIGI Ğ´Ğ»Ñ AAPL: {figi}")
    
    # Ğ¢ĞµÑÑ‚ Ğ¾Ñ€Ğ´ĞµÑ€Ğ°
    result = await client.place_market_order_async(figi, 1, "buy")
    print(f"Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚ Ğ¾Ñ€Ğ´ĞµÑ€Ğ°: {result}")

asyncio.run(main())


========================================

=== app\trading\tinkoff_client.py ===

from dataclasses import dataclass
from tinkoff.invest import (
    AsyncClient,
    InstrumentResponse,        
    PortfolioResponse,
    InstrumentIdType,
    MoneyValue
)
from decimal import Decimal
from typing import List, Optional
import logging


logger = logging.getLogger(__name__)

@dataclass
class Position:
    figi: str
    ticker: str
    lots: int
    direction: str

class TinkoffClient:
    def __init__(self, token: str, account_id: str):
        self.token = token
        self.account_id = account_id
        self.RUB_FIGI = "BBG0013HGFT4"

    async def _get_ticker_by_figi(self, figi: str) -> Optional[str]:
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ Ñ‚Ğ¸ĞºĞµÑ€ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ğ° Ğ¿Ğ¾ FIGI"""
        async with AsyncClient(self.token) as client:
            try:
                instrument: InstrumentResponse = await client.instruments.get_instrument_by(
                    id_type=InstrumentIdType.INSTRUMENT_ID_TYPE_FIGI,
                    id=figi
                )
                return instrument.instrument.ticker
            except Exception as e:
                logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ñ‚Ğ¸ĞºĞµÑ€Ğ° Ğ´Ğ»Ñ FIGI {figi}: {str(e)}")
                return None

    async def get_margin_attributes(self):
        async with AsyncClient(self.token) as client:
            return await client.operations.get_margin_attributes(account_id=self.account_id)

    async def get_positions_async(self) -> List[Position]:
        async with AsyncClient(self.token) as client:
            response = await client.operations.get_positions(account_id=self.account_id)
            positions = []
            
            for fut in response.futures:
                # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ°ĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ĞµĞ¹
                lots = abs(fut.balance) if hasattr(fut, 'balance') else abs(fut.quantity)
                direction = 'long' if (fut.balance > 0 if hasattr(fut, 'balance') else fut.quantity > 0) else 'short'
                
                ticker = await self._get_ticker_by_figi(fut.figi)
                if not ticker:
                    ticker = fut.figi  # Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ FIGI ĞµÑĞ»Ğ¸ Ñ‚Ğ¸ĞºĞµÑ€ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½
                    
                positions.append(Position(
                    ticker=ticker,
                    figi=fut.figi,
                    lots=lots,
                    direction=direction
                ))
            
            # Ğ›Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ»Ğ°Ğ´ĞºĞ¸
            logger.debug(f"Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¹: {response}")
            return positions

    async def get_balance_async(self) -> Decimal:
        async with AsyncClient(self.token) as client:
            try:
                # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾ Ğ²Ğ°Ğ»ÑÑ‚Ğ°Ğ¼
                positions = await client.operations.get_positions(account_id=self.account_id)
                logger.debug(f"Raw positions response: {positions}")
                
                rub_balance = Decimal(0)
                
                for money in positions.money:
                    if money.currency == 'rub':
                        rub_balance += self._money_value_to_decimal(money)
                
                # ĞĞ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ†ĞµĞ½Ğ½Ñ‹Ğµ Ğ±ÑƒĞ¼Ğ°Ğ³Ğ¸ Ñ Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ¾Ğ¼ Ğ² RUB
                for security in positions.securities:
                    if security.blocked == 0 and security.balance > 0:
                        instrument = await self._get_instrument_by_figi(security.figi)
                        if instrument and instrument.currency == 'rub':
                            last_price = await self._get_last_price(client, security.figi)
                            rub_balance += last_price * security.balance
                
                logger.info(f"Calculated RUB balance: {rub_balance}")
                return rub_balance
                
            except Exception as e:
                logger.error(f"Balance calculation error: {str(e)}", exc_info=True)
                raise

    async def _get_instrument_by_figi(self, figi: str):
        async with AsyncClient(self.token) as client:
            return await client.instruments.get_instrument_by(
                id_type=InstrumentIdType.INSTRUMENT_ID_TYPE_FIGI,
                id=figi
            )

    async def _get_last_price(self, client: AsyncClient, figi: str) -> Decimal:
        last_price = await client.market_data.get_last_prices(figi=[figi])
        if last_price.last_prices:
            price = last_price.last_prices[0].price
            return Decimal(price.units) + Decimal(price.nano) / Decimal(1e9)
        return Decimal(0)

    def _calculate_available_funds(self, portfolio: PortfolioResponse) -> Decimal:
        cash = next(
            (pos for pos in portfolio.positions 
             if pos.figi == self.RUB_FIGI),
            None
        )
        return self._money_value_to_decimal(cash.current_price) if cash else Decimal(0)

    async def get_figi(self, instrument: str) -> Optional[str]:
        async with AsyncClient(self.token) as client:
            # Ğ£Ğ±Ñ€Ğ°Ğ»Ğ¸ Ğ½ĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¹ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€ instrument_status
            response = await client.instruments.find_instrument(query=instrument)
            return response.instruments[0].figi if response.instruments else None


    @staticmethod
    def _money_value_to_decimal(money: MoneyValue) -> Decimal:
        """ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ°Ñ†Ğ¸Ñ MoneyValue Ğ² Decimal"""
        return Decimal(money.units) + Decimal(money.nano) / Decimal(1e9)


    async def get_balance_async(self) -> Decimal:
        """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾Ğ³Ğ¾ RUB Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ°"""
        async with AsyncClient(self.token) as client:
            try:
                positions = await client.operations.get_positions(account_id=self.account_id)
                rub_balance = Decimal(0)
                
                # ĞĞ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ€ÑƒĞ±Ğ»Ñ‘Ğ²Ñ‹Ğµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸
                for money in positions.money:
                    if money.currency == 'rub':
                        rub_balance += self._money_value_to_decimal(money)
                
                logger.debug(f"Raw RUB balance: {rub_balance}")
                return rub_balance

            except Exception as e:
                logger.error(f"Balance error: {str(e)}", exc_info=True)
                raise

========================================

=== app\trading\init.py ===

from .tinkoff_client import TinkoffClient, Position
from .order_executor import OrderExecutor

__all__ = ['TinkoffClient', 'OrderExecutor', 'Position']


========================================

=== app\trading\models.py ===

from pydantic import BaseModel
from datetime import datetime

class TradeSignal(BaseModel):
    figi: str
    direction: str  # buy/sell
    quantity: int
    timestamp: datetime

class AccountBalance(BaseModel):
    total: float
    available: float
    currency: str
    updated_at: datetime

class InstrumentCache(BaseModel):
    ticker: str
    figi: str
    min_lot: int
    updated_at: datetime    


========================================

=== app\trading\risk_manager.py ===

from decimal import Decimal
from tinkoff.invest import AsyncClient, Quotation, InstrumentShort
from redis import Redis
import logging
from config import Settings

logger = logging.getLogger(__name__)

class RiskManager:
    def __init__(self, token: str, account_id: str):
        self.token = token
        self.account_id = account_id
        self.settings = Settings()
        self.redis = Redis.from_url(self.settings.REDIS_URL)
        self.cache_ttl = 86400  # 24 Ñ‡Ğ°ÑĞ°

    async def get_figi(self, instrument_name: str) -> str:
        """ĞŸĞ¾Ğ¸ÑĞº FIGI Ñ ĞºÑÑˆĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸ĞµĞ¼"""
        cache_key = f"figi:{instrument_name}"
        cached = self.redis.get(cache_key)
        
        if cached:
            return cached.decode()

        async with AsyncClient(self.token) as client:
            try:
                response = await client.instruments.find_instrument(query=instrument_name)
                for instrument in response.instruments:
                    if instrument.ticker.upper() == instrument_name.upper():
                        figi = instrument.figi
                        self.redis.setex(cache_key, self.cache_ttl, figi)
                        return figi
                raise ValueError(f"Ğ˜Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚ {instrument_name} Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½")
            except Exception as e:
                logger.error(f"FIGI search error: {str(e)}")
                raise

    def _validate_min_lot(self, instrument: InstrumentShort, quantity: int):
        """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ»Ğ¾Ñ‚Ğ°"""
        if not hasattr(instrument, 'min_quantity_increment') or instrument.min_quantity_increment is None:
            raise ValueError("Ğ˜Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚ Ğ½Ğµ Ğ¸Ğ¼ĞµĞµÑ‚ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ»Ğ¾Ñ‚Ğ°")

        min_lot = instrument.min_quantity_increment
        if quantity < min_lot:
            raise ValueError(f"ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ {quantity} Ğ¼ĞµĞ½ÑŒÑˆĞµ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ»Ğ¾Ñ‚Ğ° {min_lot}")

    async def validate_order(self, figi: str, quantity: int) -> dict:
        """ĞÑĞ½Ğ¾Ğ²Ğ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿ĞµÑ€ĞµĞ´ Ğ¸ÑĞ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸ĞµĞ¼ Ğ¾Ñ€Ğ´ĞµÑ€Ğ°"""
        try:
            async with AsyncClient(self.token) as client:
                instrument = await client.instruments.get_instrument_by_figi(figi=figi)
                
                # Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ»Ğ¾Ñ‚Ğ°
                self._validate_min_lot(instrument, quantity)

                # ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ñ†ĞµĞ½Ñ‹ Ğ¸ Ñ€Ğ°ÑÑ‡ĞµÑ‚ ÑÑ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸
                last_price = await self._get_last_price(client, figi)
                position_cost = last_price * quantity * instrument.lot

                # ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾Ğ³Ğ¾ Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ°
                portfolio = await client.operations.get_portfolio(account_id=self.account_id)
                total = portfolio.total_amount_portfolio
                available = self._quotation_to_decimal(total)

                # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸
                checks = {
                    'min_lot': quantity >= instrument.min_quantity_increment,
                    'balance': position_cost <= available * Decimal('0.5'),
                    'daily_limit': position_cost <= Decimal('100000'),
                    'instrument_active': instrument.api_trade_available_flag
                }

                return {
                    'status': 'approved' if all(checks.values()) else 'rejected',
                    'checks': checks
                }

        except Exception as e:
            logger.error(f"Risk validation error: {str(e)}")
            return {
                'status': 'error',
                'message': str(e),
                'checks': {}
            }

    async def _get_last_price(self, client: AsyncClient, figi: str) -> Decimal:
        """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ¹ Ñ†ĞµĞ½Ñ‹"""
        order_book = await client.market_data.get_order_book(figi=figi, depth=1)
        return self._quotation_to_decimal(order_book.last_price)

    def _quotation_to_decimal(self, q: Quotation) -> Decimal:
        """ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ°Ñ†Ğ¸Ñ Quotation Ğ² Decimal"""
        return Decimal(q.units) + Decimal(q.nano) / 1e9


========================================

=== app\trading\__pycache__\__init__.cpython-311.pyc ===

ï¿½
    ï¿½4h    ï¿½                   ï¿½   ï¿½ d S )Nï¿½ r   ï¿½    ï¿½/app/trading/__init__.pyï¿½<module>r      s   ï¿½ï¿½ ï¿½ r   

========================================

=== app\trading\__pycache__\tinkoff_client.cpython-311.pyc ===

ï¿½
    ï¿½4h[  ï¿½                   ï¿½|   ï¿½ d dl mZmZmZmZ d dlmZ d dlmZm	Z	 d dl
Z
 e
j        eï¿½  ï¿½        Z G dï¿½ dï¿½  ï¿½        ZdS )ï¿½    )ï¿½AsyncClientï¿½PortfolioResponseï¿½PositionsResponseï¿½
MoneyValue)ï¿½Decimal)ï¿½Listï¿½OptionalNc                   ï¿½r   ï¿½ e Zd Zdedefdï¿½Zdefdï¿½Zdedefdï¿½Zdede	e         fd	ï¿½Z
edefd
ï¿½ï¿½   ï¿½         ZdS )ï¿½TinkoffClientï¿½tokenï¿½
account_idc                 ï¿½0   ï¿½ || _         || _        d| _        d S )Nï¿½BBG0013HGFT4)r   r   ï¿½RUB_FIGI)ï¿½selfr   r   s      ï¿½/app/trading/tinkoff_client.pyï¿½__init__zTinkoffClient.__init__   s   ï¿½ ï¿½ï¿½ï¿½
ï¿½$ï¿½ï¿½ï¿½&ï¿½ï¿½ï¿½ï¿½ï¿½    ï¿½returnc              ï¿½   ï¿½ï¿½   K  ï¿½ t          | j        ï¿½  ï¿½        4 ï¿½d {V ï¿½ï¿½}|j        ï¿½                    | j        ï¿½ï¿½  ï¿½        ï¿½ d {V ï¿½ï¿½}| ï¿½                    |ï¿½  ï¿½        cd d d ï¿½  ï¿½        ï¿½d {V ï¿½ï¿½ S # 1 ï¿½d {V ï¿½ï¿½swxY w Y   d S )N)r   )r   r   ï¿½
operationsï¿½get_portfolior   ï¿½_calculate_available_funds)r   ï¿½clientï¿½responses      r   ï¿½get_balance_asynczTinkoffClient.get_balance_async   s$  ï¿½ ï¿½ ï¿½ ï¿½ï¿½tï¿½zï¿½*ï¿½*ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½fï¿½#ï¿½.ï¿½<ï¿½<ï¿½ï¿½?ï¿½ =ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½Hï¿½ ï¿½2ï¿½2ï¿½8ï¿½<ï¿½<ï¿½		=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ï¿½ï¿½ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=ï¿½ 	=s   ï¿½;A+ï¿½+
A5ï¿½8A5ï¿½	portfolioc                 ï¿½   ï¿½ ï¿½ t          ï¿½ fdï¿½|j        D ï¿½   ï¿½         d ï¿½  ï¿½        }|rï¿½ ï¿½                    |j        ï¿½  ï¿½        nt	          dï¿½  ï¿½        S )Nc              3   ï¿½<   ï¿½K  ï¿½ | ]}|j         ï¿½j        k    ï¿½|V ï¿½ ï¿½d S )N)ï¿½figir   )ï¿½.0ï¿½posr   s     ï¿½r   ï¿½	<genexpr>z;TinkoffClient._calculate_available_funds.<locals>.<genexpr>   s=   ï¿½ï¿½ ï¿½ ï¿½ ï¿½ +ï¿½ +ï¿½Sï¿½ï¿½ï¿½Dï¿½Mï¿½)ï¿½)ï¿½ ï¿½)ï¿½)ï¿½)ï¿½)ï¿½+ï¿½ +r   r   )ï¿½nextï¿½	positionsï¿½_money_value_to_decimalï¿½current_pricer   )r   r   ï¿½cashs   `  r   r   z(TinkoffClient._calculate_available_funds   si   ï¿½ï¿½ ï¿½ï¿½+ï¿½ +ï¿½ +ï¿½ +ï¿½Iï¿½/ï¿½ +ï¿½ +ï¿½ +ï¿½ï¿½
ï¿½ 
ï¿½ï¿½
 DHï¿½Wï¿½tï¿½+ï¿½+ï¿½Dï¿½,>ï¿½?ï¿½?ï¿½?ï¿½Wï¿½UVï¿½Zï¿½Zï¿½Wr   ï¿½
instrumentc              ï¿½   ï¿½ï¿½   K  ï¿½ t          | j        ï¿½  ï¿½        4 ï¿½d {V ï¿½ï¿½}|j        ï¿½                    |ï¿½ï¿½  ï¿½        ï¿½ d {V ï¿½ï¿½}|j        r|j        d         j        nd cd d d ï¿½  ï¿½        ï¿½d {V ï¿½ï¿½ S # 1 ï¿½d {V ï¿½ï¿½swxY w Y   d S )N)ï¿½queryr   )r   r   ï¿½instrumentsï¿½find_instrumentr    )r   r)   r   r   s       r   ï¿½get_figizTinkoffClient.get_figi"   s<  ï¿½ ï¿½ ï¿½ ï¿½ï¿½tï¿½zï¿½*ï¿½*ï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½fï¿½#ï¿½/ï¿½?ï¿½?ï¿½jï¿½?ï¿½Qï¿½Qï¿½Qï¿½Qï¿½Qï¿½Qï¿½Qï¿½Qï¿½Hï¿½3;ï¿½3Gï¿½Qï¿½8ï¿½'ï¿½ï¿½*ï¿½/ï¿½/ï¿½Tï¿½	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ï¿½ï¿½ï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rï¿½ 	Rs   ï¿½<A,ï¿½,
A6ï¿½9A6c                 ï¿½ï¿½   ï¿½ t          | dï¿½  ï¿½        rIt          | dï¿½  ï¿½        r9t          | j        ï¿½  ï¿½        t          | j        ï¿½  ï¿½        t          dï¿½  ï¿½        z  z   S t          dï¿½  ï¿½        S )Nï¿½unitsï¿½nanoi Êš;r   )ï¿½hasattrr   r0   r1   )ï¿½moneys    r   r&   z%TinkoffClient._money_value_to_decimal(   s]   ï¿½ ï¿½ï¿½5ï¿½'ï¿½"ï¿½"ï¿½ 	Oï¿½wï¿½uï¿½fï¿½'=ï¿½'=ï¿½ 	Oï¿½ï¿½5ï¿½;ï¿½'ï¿½'ï¿½'ï¿½%ï¿½*ï¿½*=ï¿½*=ï¿½ï¿½ï¿½ï¿½ï¿½*Nï¿½Nï¿½Nï¿½ï¿½qï¿½zï¿½zï¿½r   N)ï¿½__name__ï¿½
__module__ï¿½__qualname__ï¿½strr   r   r   r   r   r	   r.   ï¿½staticmethodr&   ï¿½ r   r   r   r      sï¿½   ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½'ï¿½cï¿½ 'ï¿½sï¿½ 'ï¿½ 'ï¿½ 'ï¿½ 'ï¿½
=ï¿½ï¿½ =ï¿½ =ï¿½ =ï¿½ =ï¿½Xï¿½4Eï¿½ Xï¿½'ï¿½ Xï¿½ Xï¿½ Xï¿½ Xï¿½Rï¿½ï¿½ Rï¿½ï¿½#ï¿½ï¿½ Rï¿½ Rï¿½ Rï¿½ Rï¿½ ï¿½ï¿½'ï¿½ ï¿½ ï¿½ ï¿½ ï¿½\ï¿½ï¿½ ï¿½ r   r   )ï¿½tinkoff.investr   r   r   r   ï¿½decimalr   ï¿½typingr   r	   ï¿½loggingï¿½	getLoggerr4   ï¿½loggerr   r9   r   r   ï¿½<module>r@      sï¿½   ï¿½ï¿½ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ !ï¿½ !ï¿½ !ï¿½ !ï¿½ !ï¿½ !ï¿½ !ï¿½ !ï¿½ ï¿½ï¿½ï¿½ï¿½	ï¿½ï¿½	ï¿½8ï¿½	$ï¿½	$ï¿½ï¿½ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ r   

========================================

=== app\notifications.py ===

from telegram import Bot
import logging

logger = logging.getLogger(__name__)

class Notifier:
    def __init__(self, token: str, chat_id: int):
        self.bot = Bot(token=token)
        self.chat_id = chat_id

    def send_order_confirmation(self, order_details: dict):
        message = (
            f"ğŸ”„ ĞÑ€Ğ´ĞµÑ€ Ğ¸ÑĞ¿Ğ¾Ğ»Ğ½ĞµĞ½:\\n"
            f"FIGI: {order_details.figi}\\n"
            f"ĞĞ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ: {order_details.direction}\\n"
            f"ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾: {order_details.quantity}\\n"
            f"Ğ¦ĞµĞ½Ğ°: {order_details.executed_price}"
        )
        self.bot.send_message(chat_id=self.chat_id, text=message)


========================================

=== docker-compose.yml ===

version: '3.8'

services:
  bot:
    build: ./app
    command: python -m bot.main
    env_file: .env
    environment:
      - BOT_TOKEN=${BOT_TOKEN}
      - TARGET_USER_ID=${TARGET_USER_ID}
    restart: unless-stopped
    depends_on:
      - redis
      - db

  redis:
    image: redis:alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  db:
    image: postgres:13
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 5s
      timeout: 5s
      retries: 10
    volumes:
      - postgres_data:/var/lib/postgresql/data        

volumes:
  redis_data:
  postgres_data:


========================================

=== .gitignore ===

.env
*.sh
*.info
*.proj
.*
proj.*
backup.*
backup*
save*
*workly
temp
trader*
*.pyc
__pycache__


========================================

=== db\init.sql ===

CREATE TABLE IF NOT EXISTS trades (
    id SERIAL PRIMARY KEY,
    figi VARCHAR(20) NOT NULL,
    direction VARCHAR(4) NOT NULL,
    quantity INTEGER NOT NULL,
    price NUMERIC(12,4) NOT NULL,
    executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS balance_history (
    id SERIAL PRIMARY KEY,
    account_id VARCHAR(20) NOT NULL,
    balance NUMERIC(12,4) NOT NULL,
    recorded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO bot;

CREATE INDEX idx_trades_figi ON trades(figi);
CREATE INDEX idx_balance_account ON balance_history(account_id);


========================================



========================================

=== db\init.sql ===

CREATE TABLE IF NOT EXISTS trades (
    id SERIAL PRIMARY KEY,
    figi VARCHAR(20) NOT NULL,
    direction VARCHAR(4) NOT NULL,
    quantity INTEGER NOT NULL,
    price NUMERIC(12,4) NOT NULL,
    executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS balance_history (
    id SERIAL PRIMARY KEY,
    account_id VARCHAR(20) NOT NULL,
    balance NUMERIC(12,4) NOT NULL,
    recorded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO bot;

CREATE INDEX idx_trades_figi ON trades(figi);
CREATE INDEX idx_balance_account ON balance_history(account_id);


========================================

